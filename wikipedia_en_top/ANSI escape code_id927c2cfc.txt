ANSI escape code
ANSI escape sequences are a standard for in-band signaling to control cursor location, color, font styling, and other options on video text terminals and terminal emulators. Certain sequences of bytes, most starting with an ASCII escape character and a bracket character, are embedded into text.  The terminal interprets these sequences as commands, rather than text to display verbatim.
ANSI sequences were introduced in the 1970s to replace vendor-specific sequences and became widespread in the computer equipment market by the early 1980s. They are used in development, scientific, commercial text-based applications as well as bulletin board systems to offer standardized functionality.
Although hardware text terminals have become increasingly rare in the 21st century, the relevance of the ANSI standard persists because a great majority of terminal emulators and command consoles interpret at least a portion of the ANSI standard.
History
Almost all manufacturers of video terminals added vendor-specific escape sequences to perform operations such as placing the cursor at arbitrary positions on the screen. One example is the VT52 terminal, which allowed the cursor to be placed at an x,y location on the screen by sending the ESC character, a Y character, and then two characters representing numerical values equal to the x,y location plus 32 (thus starting at the ASCII space character and avoiding the control characters). The Hazeltine 1500 had a similar feature, invoked using ~, DC1 and then the X and Y positions separated with a comma. While the two terminals had identical functionality in this regard, different control sequences had to be used to invoke them.
As these sequences were different for different terminals, elaborate libraries such as termcap ("terminal capabilities") and utilities such as tput had to be created so programs could use the same API to work with any terminal. In addition, many of these terminals required sending numbers (such as row and column) as the binary values of the characters; for some programming languages, and for systems that did not use ASCII internally, it was often difficult to turn a number into the correct character.
The ANSI standard attempted to address these problems by making a command set that all terminals would use and requiring all numeric information to be transmitted as ASCII numbers. The first standard in the series was ECMA-48, adopted in 1976. It was a continuation of a series of character coding standards, the first one being ECMA-6 from 1965, a 7-bit standard from which ISO 646 originates. The name "ANSI escape sequence" dates from 1979 when ANSI adopted ANSI X3.64.  The ANSI X3L2 committee collaborated with the ECMA committee TC 1 to produce nearly identical standards. These two standards were merged into an international standard, ISO 6429. In 1994, ANSI withdrew its standard in favor of the international standard.
The first popular video terminal to support these sequences was the Digital VT100, introduced in 1978. This model was very successful in the market, which sparked a variety of VT100 clones, among the earliest and most popular of which was the much more affordable Zenith Z-19 in 1979.  Others included the Qume QVT-108, Televideo TVI-970, Wyse WY-99GT as well as optional "VT100" or "VT103" or "ANSI" modes with varying degrees of compatibility on many other brands. The popularity of these gradually led to more and more software (especially bulletin board systems and other online services) assuming the escape sequences worked, leading to almost all new terminals and emulator programs supporting them.
In 1981, ANSI X3.64 was adopted for use in the US government by FIPS publication 86.  Later, the US government stopped duplicating industry standards, so FIPS pub. 86 was withdrawn.
ECMA-48 has been updated several times and is currently at its 5th edition, from 1991. It is also adopted by ISO and IEC as standard ISO/IEC 6429. A version is adopted as a Japanese Industrial Standard, as JIS X 0211.
Related standards include ITU T.61, the Teletex standard, and the ISO/IEC 8613, the Open Document Architecture standard (mainly ISO/IEC 8613-6 or ITU T.416). The two systems share many escape codes with the ANSI system, with extensions that are not necessarily meaningful to computer terminals. Both systems quickly fell into disuse, but ECMA-48 does mark the extensions used in them as reserved.
Platform support
Unix-like systems
On these systems the terminal (or emulator) self-identifies using the $TERM environment variable. A database library such as termcap or terminfo would perform a lookup to derive the capabilities of the terminal and specific escape sequences to use the capabilities, which may deviate from ANSI in early days.
Although such libraries were primarily developed on and for Unix, by the mid-1980s programs running on Unix-like operating systems could almost always assume they were using a terminal or emulator that supported ANSI sequences; this led to widespread use of ANSI by programs running on those platforms. For instance, many games and shell scripts, and utilities such as color directory listings, directly write the ANSI sequences and thus cannot be used on a terminal that does not interpret them. Many programs, including text editors such as vi and GNU Emacs, use termcap or terminfo, or use libraries such as curses that use termcap or terminfo, and thus in theory support non-ANSI terminals, but this is so rarely tested nowadays that they are unlikely to work with those terminals.
Terminal emulators for communicating with local programs as well as remote machines and the text system console almost always support ANSI escape codes. This includes terminal emulators such as xterm, rxvt, GNOME Terminal, and Konsole on systems with X11-based or Wayland-based window systems, and Terminal.app and third-party terminal emulators such as iTerm2 on macOS.
CP/M
CP/M machines varied and several competing terminals existed, like for printers, each with their own control sequences.  Some early systems were headless (needing an external terminal) and personal computers with a native screen typically emulated a terminal.  Application developers had to support various popular terminals and to provide an installation program to configure them.  Despite the CP/M hardware abstraction layer (BIOS), even for the same microprocessor, vendors provided platform-specific versions due to the competing disk formats, that would also be preconfigured for the native terminal (for example, various machine-specific WordStar adaptations were released).
The headless Altair 8800 was typically connected to a teletype such as the Model 33 ASR or to an external terminal like the TeleVideo 920C, needing to output their respective sequences.  The Osborne 1 and Kaypro II computers natively emulated a subset of the TeleVideo 920C and ADM-3A control codes, respectively.  The TRS-80 Model 4 and the Xerox 820 also emulated the Lear Siegler ADM-3A.  The Zenith Z-89, Heathkit H8 and Amstrad PCW CP/M-80 computers implemented the Zenith Z19 (Heathkit H19) terminal codes, mostly compatible with VT52, the Z-89 manual also describes it as supporting ANSI.
The Microsoft Z-80 SoftCard for the Apple II emulated a limited subset of the Videx Videoterm, corresponding to the Datamedia 1520 sequences that the UCSD-based Apple Pascal supported.  Its CP/M had the CONFIGIO command to adapt external terminals or run local applications that issued other control codes.  Supported external terminals were the Soroc IQ 120/140 and Hazeltine 1500/1510.
DOS, OS/2, and Windows
MS-DOS 1.x did not support the ANSI or any other escape sequences. Only a few control characters (BEL, CR, LF, BS) were interpreted by the underlying BIOS, making it almost impossible to do any kind of full-screen application. Any display effects had to be done with BIOS calls, which were notoriously slow, or by directly manipulating the IBM PC hardware.
DOS 2.0 introduced the ability to add a device driver for the ANSI escape sequences â€“ the de facto standard being ANSI.SYS, but others like ANSI.COM, NANSI.SYS and ANSIPLUS.EXE are used as well (these are considerably faster as they bypass the BIOS). Slowness and the fact that it was not installed by default made software rarely take advantage of it; instead, applications continued to directly manipulate the hardware to get the text display needed. ANSI.SYS and similar drivers continued to work in Windows 9x up to Windows Me, and in NT-derived systems for 16-bit legacy programs executing under the NTVDM.
Many clones of DOS were able to interpret the sequences and do not require a separate ANSI driver to be loaded. PTS-DOS as well as Concurrent DOS, Multiuser DOS and REAL/32 have built-in support (plus a number of extensions). OS/2 had an ANSI command that enabled the sequences.
The Windows Console did not support ANSI escape sequences, nor did Microsoft provide any method to enable them. Some replacements or additions for the console window such as JP Software's TCC (formerly 4NT), Michael J. Mefford's ANSI.COM, Jason Hood's ANSICON and Maximus5's ConEmu interpreted ANSI escape sequences printed by programs. A Python package named colorama   internally interpretes ANSI escape sequences in text being printed, translating them to win32 calls to modify the state of the terminal, to make it easier to port Python code using ANSI to Windows. Cygwin performs similar translation to all output written to the console using Cygwin file descriptors, the filtering is done by the output functions of cygwin1.dll, to allow porting of POSIX C code to Windows.
In 2016, Microsoft released the Windows 10 version 1511 update which unexpectedly implemented support for ANSI escape sequences, over two decades after the debut of Windows NT. This was done alongside Windows Subsystem for Linux, allowing Unix-like terminal-based software to use the sequences in Windows Console. This defaults to off, but Windows PowerShell 5.1 enabled it. PowerShell 6 made it possible to embed the necessary ESC character into a string with `e. 
Windows Terminal, introduced in 2019, supports the sequences by default, and Microsoft intends to replace the Windows Console with Windows Terminal.
Atari ST/TT/Falcon series
Atari TOS used the command system adapted from the VT52 with some expansions for color support, rather than supporting ANSI escape codes.
AmigaOS
AmigaOS not only interprets ANSI code sequences for text output to the screen, the AmigaOS printer driver also interprets them (with extensions proprietary to AmigaOS) and translates them into the codes required for the particular printer that is actually attached.
VMS / OpenVMS
VMS was designed to be controlled using Digital's text-based video terminals such as the aforementioned VT100; thus software tends to write the ANSI escape sequences directly (and will not work on non-ANSI terminals).
Description
C0 control codes
Almost all users assume some functions of some single-byte characters. Initially defined as part of ASCII, the default C0 control code set is now defined in ISO 6429 (ECMA-48), making it part of the same standard as the C1 set invoked by the ANSI escape sequences (although ISO 2022 allows the ISO 6429 C0 set to be used without the ISO 6429 C1 set, and vice versa, provided that 0x1B is always ESC). This is used to shorten the amount of data transmitted, or to perform some functions that are unavailable from escape sequences:
Escape sequences vary in length. The general format for an ANSI-compliant escape sequence is defined by ANSI X3.41 (equivalent to ECMA-35 or ISO/IEC 2022).: 13.1  The escape sequences consist only of bytes in the range 0x20â€”0x7F (all the non-control ASCII characters), and can be parsed without looking ahead. The behavior when a control character, a byte with the high bit set, or a byte that is not part of any valid sequence, is encountered before the end is undefined.
Fe Escape sequences
If the ESC is followed by a byte in the range 0x40 to 0x5F, the escape sequence is of type Fe. Its interpretation is delegated to the applicable C1 control code standard.: 13.2.1  Accordingly, all escape sequences corresponding to C1 control codes from ANSI X3.64 / ECMA-48 follow this format.: 5.3.a 
The standard says that, in 8-bit environments, the control functions corresponding to type Fe escape sequences (those from the set of C1 control codes) can be represented as single bytes in the 0x80â€“0x9F range.: 5.3.b  This is possible in character encodings conforming to the provisions for an 8-bit code made in ISO 2022, such as the ISO 8859 series. However, in character encodings used on modern devices such as UTF-8 or CP-1252, those codes are often used for other purposes, so only the 2-byte sequence is typically used. In the case of UTF-8, representing a C1 control code via the C1 Controls and Latin-1 Supplement block results in a different two-byte code (e.g. 0xC2,0x8E for U+008E), but no space is saved this way.


CSI (Control Sequence Introducer) sequences
For Control Sequence Introducer, or CSI, commands, the ESC [ (written as \e[ or \033[ in several programming and scripting languages) is followed by any number (including none) of "parameter bytes" in the range 0x30â€“0x3F (ASCII 0â€“9:;<=>?), then by any number of "intermediate bytes" in the range 0x20â€“0x2F (ASCII space and !"#$%&'()*+,-./), then finally by a single "final byte" in the range 0x40â€“0x7E (ASCII @Aâ€“Z[\]^_`aâ€“z{|}~).: 5.4 
All common sequences just use the parameters as a series of semicolon-separated numbers such as 1;2;3. Missing numbers are treated as 0 (1;;3 acts like the middle number is 0, and no parameters at all in ESC[m acts like a 0 reset code). Some sequences (such as CUU) treat 0 as 1 in order to make missing parameters useful.: F.4.2 
A subset of arrangements was declared "private" so that terminal manufacturers could insert their own sequences without conflicting with the standard. Sequences containing the parameter bytes <=>? or the final bytes 0x70â€“0x7E (pâ€“z{|}~) are private.
The behavior of the terminal is undefined in the case where a CSI sequence contains any character outside of the range 0x20â€“0x7E. These illegal characters are either C0 control characters (the range 0â€“0x1F), DEL (0x7F), or bytes with the high bit set. Possible responses are to ignore the byte, to process it immediately, and furthermore whether to continue with the CSI sequence, to abort it immediately, or to ignore the rest of it.
SGR (Select Graphic Rendition) parameters
The control sequence CSI n m, named Select Graphic Rendition (SGR), sets display attributes. Several attributes can be set in the same sequence, separated by semicolons. Each display attribute remains in effect until a following occurrence of SGR resets it. If no codes are given, CSI m is treated as CSI 0 m (reset / normal).
3-bit and 4-bit
The original specification only had 8 colors, and just gave them names. The SGR parameters 30â€“37 selected the foreground color, while 40â€“47 selected the background. Quite a few terminals implemented "bold" (SGR code 1) as a brighter color rather than a different font, thus providing 8 additional foreground colors. Usually you could not get these as background colors, though sometimes inverse video (SGR code 7) would allow that. Examples: to get black letters on white background use ESC[30;47m, to get red use ESC[31m, to get bright red use ESC[1;31m. To reset colors to their defaults, use ESC[39;49m (not supported on some terminals), or reset all attributes with ESC[0m. Later terminals added the ability to directly specify the "bright" colors with 90â€“97 and 100â€“107.
When hardware started using 8-bit digital-to-analog converters (DACs) several pieces of software assigned 24-bit color numbers to these names. The chart below shows the default values sent to the DAC for some common hardware and software; in most cases they are configurable.
8-bit
As 256-color lookup tables became common on graphic cards, escape sequences were added to select from a pre-defined set of 256 colors:
The ITU's T.416 Information technology - Open Document Architecture (ODA) and interchange format: Character content architectures uses ':' as separator characters instead:
There has also been a similar but incompatible 88-color encoding using the same escape sequence, seen in rxvt and xterm-88color. Not much is known about the scheme besides the color codes. It uses a 4Ã—4Ã—4 color cube.
24-bit
As "true color" graphic cards with 16 to 24 bits of color became common, applications began to support 24-bit colors. Terminal emulators supporting setting 24-bit foreground and background colors with escape sequences include Xterm, KDE's Konsole, and iTerm, as well as all libvte based terminals, including GNOME Terminal.
The syntax is likely based on the ITU's T.416 Open Document Architecture (ODA) and interchange format: Character content architectures, which was adopted as ISO/IEC 8613-6 but ended up as a commercial failure. The ODA version is more elaborate and thus incompatible:
The ITU-RGB variation is supported by xterm, with the colorspace ID and tolerance parameters ignored. The simpler scheme using semicolons is initially found in Konsole.: Can I set a color by its number? 
Unix environment variables relating to color support
Before termcap and terminfo could indicate support for colors, the S-Lang library used $COLORTERM to indicate whether a terminal emulator could use colors at all (later reinterpreted as 256-colors) and whether it supports 24-bit color. This system, although poorly documented, became widespread enough for Fedora and RHEL to consider using it as a simpler and more universal detection mechanism compared to querying the now-updated libraries. However, gnome-terminal 3.14 dropped this variable as its authors considered it incorrect and no longer necessary.
Some terminal emulators (urxvt, konsole) set $COLORFGBG to report the color scheme of the terminal (mainly light vs. dark background). This behavior originated in S-Lang and is used by vim. Again, gnome-terminal refuses to add this behavior, as the more "proper" xterm OSC 4/10/11 sequences already exist.
OSC (Operating System Command) sequences
Most Operating System Command sequences were defined by Xterm, but many are also supported by other terminal emulators. For historical reasons, Xterm can end the command with BEL as well as the standard ST. For example, Xterm allows the window title to be set by ESC ]0;this is the window title BEL.
A non-xterm extension is the hyperlink, ESC ]8;;link ST from 2017, used by VTE, iTerm2, and mintty.
The Linux console uses ESC ] P n rr gg bb to change the palette, which, if hard-coded into an application, may hang other terminals. However, appending ST will be ignored by Linux and form a proper, ignorable sequence for other terminals.
Fs Escape sequences
If the ESC is followed by a byte in the range 0x60â€”0x7E, the escape sequence is of type Fs. This type is used for control functions individually registered with the ISO-IR registry and, consequently, available even in contexts where a different C1 control code set is used. Specifically, they correspond to single control functions approved by ISO/IEC JTC 1/SC 2 and standardized by ISO or an ISO-recognised body.: 6.5.1  Some of these are specified in ECMA-35 (ISO 2022 / ANSI X3.41), others in ECMA-48 (ISO 6429 / ANSI X3.64).: 6.5.4  ECMA-48 refers to these as "independent control functions".: 5.5 
Fp Escape sequences
If the ESC is followed by a byte in the range 0x30â€”0x3F, the escape sequence is of type Fp, which is set apart for up to sixteen private-use control functions.: 6.5.3 
nF Escape sequences
If the ESC is followed by a byte in the range 0x20â€”0x2F, the escape sequence is of type nF. Said byte is followed by any number of additional bytes in this range, and then a byte in the range 0x30-0x7E. These escape sequences are further subcategorised by the low four bits of the first byte, e.g. "type 2F" for sequences where the first byte is 0x22; and by whether the final byte is in the range 0x30â€”0x3F indicating private use (e.g. "type 2Fp") or not (e.g. "type 2Ft").: 13.2.1 
Escape sequences of this type are mostly used for ANSI/ISO code-switching mechanisms such as those used by ISO-2022-JP, except for type 3F sequences (those where the first intermediate byte is 0x23), which are used for individual control functions. Type 3Ft sequences are reserved for additional ISO-IR registered individual control functions,: 6.5.2  while type 3Fp sequences are available for private-use control functions.: 6.5.3  Unlike type Fs sequences, no type 3Ft sequences are presently registered.
Examples
CSI 2 J â€” This clears the screen and, on some devices, locates the cursor to the y,x position 1,1 (upper left corner).
CSI 32 m â€” This makes text green. The green may be a dark, dull green, so you may wish to enable Bold with the sequence CSI 1 m which would make it bright green, or combined as CSI 32 ; 1 m.  Some implementations use the Bold state to make the character Bright.
CSI 0 ; 6 8 ; "DIR" ; 13 p â€” This reassigns the key F10 to send to the keyboard buffer the string "DIR" and ENTER, which in the DOS command line would display the contents of the current directory. (MS-DOS ANSI.SYS only) This was sometimes used for ANSI bombs.  This is a private-use code (as indicated by the letter p), using a non-standard extension to include a string-valued parameter.  Following the letter of the standard would consider the sequence to end at the letter D.
CSI s â€” This saves the cursor position. Using the sequence CSI u will restore it to the position. Say the current cursor position is 7(y) and 10(x). The sequence CSI s will save those two numbers. Now you can move to a different cursor position, such as 20(y) and 3(x), using the sequence CSI 20 ; 3 H or CSI 20 ; 3 f. Now if you use the sequence CSI u the cursor position will return to 7(y) and 10(x). Some terminals require the DEC sequences ESC 7 / ESC 8 instead which is more widely supported.
In shell scripting
ANSI escape codes are often used in UNIX and UNIX-like terminals to provide syntax highlighting. For example, on compatible terminals, the following list command color-codes file and directory names by type.
Users can employ escape codes in their scripts by including them as part of standard output or standard error. For example, the following GNU sed command embellishes the output of the make command by displaying lines containing words starting with "WARN" in reverse video and words starting with "ERR" in bright yellow on a dark red background (letter case is ignored). The representations of the codes are highlighted.
The following Bash function flashes the terminal (by alternately sending reverse and normal video mode codes) until the user presses a key.
This can be used to alert a programmer when a lengthy command terminates, such as with make ; flasher .
This will reset the console, similar to the command reset on modern Linux systems; however it should work even on older Linux systems and on other (non-Linux) UNIX variants.
Terminal input sequences
Pressing special keys on the keyboard, as well as outputting many xterm CSI, DCS, or OSC sequences, often produces a CSI, DCS, or OSC sequence, sent from the terminal to the computer as though the user typed it.
When typing input on a terminal keypresses outside the normal main alphanumeric keyboard area can be sent to the host as ANSI sequences. For keys that have an equivalent output function, such as the cursor keys, these often mirror the output sequences. However, for most keypresses there isn't an equivalent output sequence to use.
There are several encoding schemes, and unfortunately most terminals mix sequences from different schemes, so host software has to be able to deal with input sequences using any scheme. 
To complicate the matter, the VT terminals themselves have two schemes of input, normal mode and application mode that can be switched by the application.
(draft section)
If the terminating character is '~', the first number must be present and is a
keycode number, the second number is an optional modifier value. If the terminating
character is a letter, the letter is the keycode value, and the optional number is
the modifier value.
The modifier value defaults to 1, and after subtracting 1 is a bitmap of modifier
keys being pressed: Meta+Ctrl+Alt+â‡§ Shift. So, for example, <esc>[4;2~ is
â‡§ Shift+End, <esc>[20~ is function key F9, <esc>[5C is Ctrl+â†’.
In other words, the modifier is the sum of the following numbers:
<esc>[A to <esc>[D are the same as the ANSI output sequences. The <modifier> is normally omitted if no modifier keys are pressed, but most implementations always emit the <modifier> for F1â€“F4. (draft section)
Xterm has a comprehensive documentation page on the various function-key and mouse input sequence schemes from DEC's VT terminals and various other terminals it emulates. Thomas Dickey has added a lot of support to it over time; he also maintains a list of default keys used by other terminal emulators for comparison.
See also
Notes