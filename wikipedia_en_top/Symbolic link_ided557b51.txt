Symbolic link
In computing, a symbolic link (also symlink or soft link) is a file whose purpose is to point to a file or directory (called the "target") by specifying a path thereto.
Symbolic links are supported by POSIX and by most Unix-like operating systems, such as FreeBSD, Linux, and macOS. Limited support also exists in Windows 7 and Windows Vista, and to some degree in Windows 2000 and Windows XP in the form of shortcut files. CTSS on IBM 7090 had files linked by name in 1963. By 1978 minicomputer operating systems from DEC, and in Data General's RDOS included symbolic links.
Overview
A symbolic link contains a text string that is automatically interpreted and followed by the operating system as a path to another file or directory. This other file or directory is called the "target". The symbolic link is a second file that exists independently of its target. If a symbolic link is deleted, its target remains unaffected. If a symbolic link points to a target, and sometime later that target is moved, renamed or deleted, the symbolic link is not automatically updated or deleted, but continues to exist and still points to the old target, now a non-existing location or file. Symbolic links pointing to moved or non-existing targets are sometimes called broken, orphaned, dead, or dangling.
Symbolic links are different from hard links. Hard links do not link paths on different volumes or file systems, whereas symbolic links may point to any file or directory irrespective of the volumes on which the link and target reside.
Hard links always refer to an existing file, whereas symbolic links may contain an arbitrary path that does not point to anything.
Symbolic links operate transparently for many operations: programs that read or write to files named by a symbolic link will behave as if operating directly on the target file. However, they have the effect of changing an otherwise hierarchic filesystem from a tree into a directed graph, which can have consequences for such simple operations as determining the current directory of a process. Even the Unix standard for navigating to a directory's parent directory no longer works reliably in the face of symlinks. Some shells heuristically try to uphold the illusion of a tree-shaped hierarchy, but when they do, this causes them to produce different results from other programs that manipulate pathnames without such heuristic, relying on the operating system instead.
Programs that need to handle symbolic links specially (e.g., shells and backup utilities) thus need to identify and manipulate them directly.
Some Unix as well as Linux distributions use symbolic links extensively in an effort to reorder the file system hierarchy. This is accomplished with several mechanisms, such as variant, context-dependent symbolic links. This offers the opportunity to create a more intuitive or application-specific directory tree and to reorganize the system without having to redesign the core set of system functions and utilities.
POSIX and Unix-like operating systems
In POSIX-compliant operating systems, symbolic links are created with the symlink system call.  The ln shell command normally uses the link system call, which creates a hard link.  When the ln -s flag is specified, the symlink() system call is used instead, creating a symbolic link. Symlinks were introduced in 4.1c.1 BSD Unix from U.C. Berkeley.
The following command creates a symbolic link at the command-line interface (shell):
target_path is the relative or absolute path to which the symbolic link should point.  Usually the target will exist, although symbolic links may be created to non-existent targets. link_path is the path of the symbolic link.
After creating the symbolic link, some operations can be used to treat it as an alias for the target. However, the lstat, lchown and readlink operations are unique to symbolic links and do not apply to the target; by using those system calls, programs that examine the file system (e.g., ls, find) can report on symbolic links (instead of their targets, if any).  Because the rename and unlink system calls are coded to operate directly on symbolic links, file system management commands (e.g.,  rm, mv) affect the symbolic link itself (instead of being applied to the symbolic link target, if any).  The rm (delete file) command removes the link itself, not the target file. Likewise, the mv command moves or renames the link, not the target. The cp command has options that allow either the symbolic link or the target to be copied. Commands which read or write file contents will access the contents of the target file.
The POSIX directory listing application, ls, denotes symbolic links with an arrow after the name, pointing to the name of the target file (see following example), when the long directory list is requested (-l option). When a directory listing of a symbolic link that points to a directory is requested, only the link itself will be displayed. In order to obtain a listing of the linked directory, the path must include a trailing directory separator character ('/', slash).
Note: In the example below do not create "three" directory before creation of link in /tmp directory.
Storage of symbolic links
Early implementations of symbolic links stored the symbolic link information as data in regular files. The file contained the textual reference to the link's target, and the file mode bits indicated that the type of the file is a symbolic link.
This method was slow and an inefficient use of disk-space on small systems.  An improvement, called fast symlinks, allowed storage of the target path within the data structures used for storing file information on disk (inodes). This space normally stores a list of disk block addresses allocated to a file. Thus, symlinks with short target paths are accessed quickly. Systems with fast symlinks often fall back to using the original method if the target path exceeds the available inode space. The original style is retroactively termed a slow symlink. It is also used for disk compatibility with other or older versions of operating systems.
Although storing the link value inside the inode saves a disk block and a disk read, the operating system still needs to parse the path name in the link, which always requires reading additional inodes and generally requires reading other, and potentially many, directories, processing both the list of files and the inodes of each of them until it finds a match with the link's path components. Only when a link points to a file in the same directory do "fast symlinks" provide significantly better performance than other symlinks.
The vast majority of POSIX-compliant implementations use fast symlinks. However, the POSIX standard does not require the entire set of file status information common to regular files to be implemented for symlinks. This allows implementations to use other solutions, such as storing symlink data in directory entries.
The file system permissions of a symbolic link are not used; the access modes of the target file are controlled by the target file's own permissions.  Some operating systems, such as FreeBSD, offer the ability to modify file permissions and filesystem attributes of a symbolic link, through lchmod and lchflags system calls respectively.
The reported size of a symlink is the number of characters in the path it points to.
Error handling
A traditional Unix filesystem has a tree structure, however symbolic links allow it to contain loops.
Microsoft Windows
NTFS symbolic link
NTFS 3.1 introduced support for symbolic links for any type of file. It was included with Windows XP, but was only enabled by default for kernel mode programs; Windows Vista and later versions of Windows enabled support for symbolic links to user mode applications, as well, and supplied the command line utility mklink for creating them. Third-party drivers are required to enable support for NTFS symbolic links in Windows XP. Unlike junction points, a symbolic link can also point to a file or remote Server Message Block (SMB) network path. Additionally, the NTFS symbolic link implementation provides full support for cross-filesystem links. However, the functionality enabling cross-host symbolic links requires that the remote system also support them.
Symbolic links are designed to aid in migration and application compatibility with POSIX operating systems. Microsoft aimed for Windows Vista's symbolic links to "function just like UNIX links". However, the implementation differs from Unix symbolic links in several ways. For example, Windows Vista users must manually indicate when creating a symbolic link whether it is a file or a directory. Windows 7 and Vista support a maximum of 31 reparse points (and therefore symbolic links) for a given path (i.e. any given path can have at most 31 indirections before Windows gives up). Only users with the new Create Symbolic Link privilege, which only administrators have by default, can create symbolic links. If this is not the desired behavior, it must be changed in the Local Security Policy management console. Additionally, NTFS symbolic links to files are distinct from NTFS symbolic links to directories and therefore cannot be used interchangeably, unlike on POSIX where the same symbolic link can refer to either files or directories.
In Windows Vista and later, when the working directory path ends with a symbolic link, the current parent path reference, .., will refer to the parent directory of the symbolic link rather than that of its target. This behaviour is also found at the shell level in at least some POSIX systems, including Linux, but never in accessing files and directories through operating system calls.  For instance, bash builtin commands pwd and cd operate on the current logical directory.  pwd is often used in scripts to determine the actual current working directory.  When any path is used with a system call, any use of .. will use the actual filesystem parent of the directory containing the .. pseudo-directory entry.  So, cd ..; cat something and cat ../something may return completely different results.
Examples
NTFS junction points
The Windows 2000 version of NTFS introduced reparse points, which enabled, among other things, the use of Volume Mount Points and junction points.  Junction points are for directories only, and moreover, local directories only; junction points to remote shares are unsupported.  The Windows 2000 and XP Resource Kits include a program called linkd to create junction points; a more powerful one named Junction was distributed by Sysinternals' Mark Russinovich.
Not all standard applications support reparse points. Most noticeably, Backup suffers from this problem and will issue an error message 0x80070003 when the folders to be backed up contain a reparse point.
Shortcuts
Shortcuts, which are supported by the graphical file browsers of some operating systems, may resemble symbolic links but differ in a number of important ways. One difference is what type of software is able to follow them:
Another difference are the capabilities of the mechanism:
Folder shortcuts
Almost like shortcuts, but transparent to the Windows shell. They are implemented as ordinary folders (which need to have the read only and/or system attribute) containing a shortcut named target.lnk which refers to the target and a (hidden) desktop.ini with (at least) the following contents:
Folder shortcuts are created and used from the Windows shell in the network neighborhood for example.
Shell objects
The shell objects or shell folders are defined in the Windows registry and can be used to implement a sort of symbolic link too. Like folder shortcuts, they are transparent to the Windows shell.
A minimal implementation is (the CLSID {00000000-0000-0000-0000-000000000000} is used as a placeholder):
The My Documents folder on the Desktop as well as the Fonts and the Administrative Tools folders in the Control Panel are examples of shell objects redirected to file-system folders.
Cygwin symbolic links
Cygwin simulates POSIX-compliant symbolic links in the Microsoft Windows file system. It uses identical programming and user utility interfaces as Unix (see above), but creates Windows shortcuts (.lnk files) with additional information used by Cygwin at the time of symlink resolution. Cygwin symlinks are compliant with the POSIX standard in terms of how they are resolved, and with Windows standards in terms of their on-disk representation.
Additionally, Cygwin can be set up to support native Windows symbolic links which can be used out of Cygwin without restrictions. This requires:
Some differences exist, however. Cygwin has no way to specify shortcut-related information – such as working directory or icon – as there is no place for such parameters in ln -s command. To create standard Microsoft .lnk files Cygwin provides the mkshortcut and readshortcut utilities.
The Cygwin User's Guide has more information on this topic. MSYS2, which is based on Cygwin, has a similar set of winsymlinks settings but defaults to copying the files.
Comparison of POSIX and Windows symbolic links
Other implementations
Implementations of features similar to symbolic links.
Early MIT
MIT Compatible Time-Sharing System c. 1963 and Incompatible Timesharing System both have linked files where the name of the target file is specified in a directory entry.
Amiga
The command creating symbolic links is makelink, which is also used for hard links. Internally the dos.library returns an error code indicating that a target is a soft link if you try to perform actions on it that are only legal for a file, and applications that wish to follow the symbolic link then needs to explicitly make a call to follow the link and retry the operation. The AmigaDOS shell will follow links automatically.
Mac OS
In Mac OS, applications or users can also employ aliases, which have the added feature of following the target, even if it is moved to another location on the same volume. This is not to be confused with the shell command alias.
OS/2
In the OS/2 operating system, symbolic links somewhat resemble shadows in the graphical Workplace Shell. However, shadows, due to the fully object-oriented System Object Model, are considerably more powerful and robust than a simple link. For example, shadows do not lose their capabilities when renamed or when either the object or subject of the link is relocated.
Variable symbolic links
Symbolic links may be implemented in a context-dependent or variable fashion, such that the link points to varying targets depending on a configuration parameter, run-time parameter, or other instantaneous condition.
A variable or variant symbolic link is a symbolic link that has a variable name embedded in it. This allows some flexibility in filesystem order that is not possible with a standard symbolic link. Variables embedded in a symbolic link may include user and environment specific information.
Operating systems that make use of variant symbolic links include NetBSD, DragonFly BSD, Domain/OS.
Tru64 uses a context dependent symbolic link where the context is the cluster member number.
Pyramid Technology's OSx Operating System implemented conditional symbolic links which pointed to different locations depending on which universe a program was running in.  The universes supported were AT&Ts's SysV.3 and the Berkeley Software Distribution (BSD 4.3). For example: if the ps command was run in the att universe, then the symbolic link for the directory /bin would point to /.attbin and the program /.attbin/ps would be executed. Whereas if the ps command was run in the ucb universe, then /bin would point to /.ucbbin and /.ucbbin/ps would be executed. Similar Conditional Symbolic Links were also created for other directories such as /lib, /usr/lib, /usr/include.