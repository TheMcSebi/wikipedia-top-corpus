Softmax function
The softmax function, also known as softargmax: 184  or normalized exponential function,: 198  converts a vector of K real numbers into a probability distribution of K possible outcomes. It is a generalization of the logistic function to multiple dimensions, and used in multinomial logistic regression. The softmax function is often used as the last activation function of a neural network to normalize the output of a network to a probability distribution over predicted output classes, based on Luce's choice axiom.
Definition
The softmax function takes as input a vector z of K real numbers, and normalizes it into a probability distribution consisting of K probabilities proportional to the exponentials of the input numbers. That is, prior to applying softmax, some vector components could be negative, or greater than one; and might not sum to 1; but after applying softmax, each component will be in the interval $MATH$, and the components will add up to 1, so that they can be interpreted as probabilities. Furthermore, the larger input components will correspond to larger probabilities. 
The standard (unit) softmax function $MATH$ :\mathbb {R} ^{K}\to (0,1)^{K}}
  
is defined when $MATH$ by the formula
In simple words, it applies the standard exponential function to each element $MATH$ of the input vector $MATH$ and normalizes these values by dividing by the sum of all these exponentials; this normalization ensures that the sum of the components of the output vector $MATH$ is 1.
Instead of e, a different base b > 0 can be used.  If 0 < b < 1, smaller input components will result in larger output probabilities, and decreasing the value of b will create probability distributions that are more concentrated around the positions of the smallest input values. Conversely, if b > 1, larger input components will result in larger output probabilities, and increasing the value of b will create probability distributions that are more concentrated around the positions of the largest input values. Writing $MATH$ or $MATH$ (for real β) yields the expressions:
In some fields, the base is fixed, corresponding to a fixed scale, while in others the parameter β is varied.
Interpretations
Smooth arg max
The name "softmax" is misleading; the function is not a smooth maximum (a smooth approximation to the maximum function), but is rather a smooth approximation to the arg max function: the function whose value is which index has the maximum. In fact, the term "softmax" is also used for the closely related LogSumExp function, which is a smooth maximum. For this reason, some prefer the more accurate term "softargmax", but the term "softmax" is conventional in machine learning. This section uses the term "softargmax" to emphasize this interpretation.
Formally, instead of considering the arg max as a function with categorical output $MATH$ (corresponding to the index), consider the arg max function with one-hot representation of the output (assuming there is a unique maximum arg):
where the output coordinate $MATH$ if and only if $MATH$ is the arg max of $MATH$, meaning $MATH$ is the unique maximum value of $MATH$. For example, in this encoding $MATH$ since the third argument is the maximum.
This can be generalized to multiple arg max values (multiple equal $MATH$ being the maximum) by dividing the 1 between all max args; formally 1/k where k is the number of arguments assuming the maximum. For example, $MATH$ since the second and third argument are both the maximum. In case all arguments are equal, this is simply $MATH$ Points z with multiple arg max values are singular points (or singularities, and form the singular set) – these are the points where arg max is discontinuous (with a jump discontinuity) – while points with a single arg max are known as non-singular or regular points.
With the last expression given in the introduction, softargmax is now a smooth approximation of arg max: as $MATH$, softargmax converges to arg max. There are various notions of convergence of a function; softargmax converges to arg max pointwise, meaning for each fixed input z as $MATH$, $MATH$ However, softargmax does not converge uniformly to arg max, meaning intuitively that different points converge at different rates, and may converge arbitrarily slowly. In fact, softargmax is continuous, but arg max is not continuous at the singular set where two coordinates are equal, while the uniform limit of continuous functions is continuous. The reason it fails to converge uniformly is that for inputs where two coordinates are almost equal (and one is the maximum), the arg max is the index of one or the other, so a small change in input yields a large change in output. For example, $MATH$ but $MATH$ and $MATH$ for all inputs: the closer the points are to the singular set $MATH$, the slower they converge. However, softargmax does converge compactly on the non-singular set.
Conversely, as $MATH$, softargmax converges to arg min in the same way, where here the singular set is points with two arg min values. In the language of tropical analysis, the softmax is a deformation or "quantization" of arg max and arg min, corresponding to using the log semiring instead of the max-plus semiring (respectively min-plus semiring), and recovering the arg max or arg min by taking the limit is called "tropicalization" or "dequantization".
It is also the case that, for any fixed β, if one input $MATH$ is much larger than the others relative to the temperature, $MATH$, the output is approximately the arg max. For example, a difference of 10 is large relative to a temperature of 1:
However, if the difference is small relative to the temperature, the value is not close to the arg max. For example, a difference of 10 is small relative to a temperature of 100:
As $MATH$, temperature goes to zero, $MATH$, so eventually all differences become large (relative to a shrinking temperature), which gives another interpretation for the limit behavior.
Probability theory
In probability theory, the output of the softargmax function can be used to represent a categorical distribution – that is, a probability distribution over K different possible outcomes.
Statistical mechanics
In statistical mechanics, the softargmax function is known as the Boltzmann distribution (or Gibbs distribution):: 7  the index set $MATH$ are the microstates of the system; the inputs $MATH$ are the energies of that state; the denominator is known as the partition function, often denoted by Z; and the factor β is called the coldness (or thermodynamic beta, or inverse temperature).
Applications
The softmax function is used in various multiclass classification methods, such as multinomial logistic regression (also known as softmax regression): 206–209  , multiclass linear discriminant analysis, naive Bayes classifiers, and artificial neural networks. Specifically, in multinomial logistic regression and linear discriminant analysis, the input to the function is the result of K distinct linear functions, and the predicted probability for the jth class given a sample vector x and a weighting vector w is:
This can be seen as the composition of K linear functions $MATH$ and the softmax function (where $MATH$ denotes the inner product of $MATH$ and $MATH$). The operation is equivalent to applying a linear operator defined by $MATH$ to vectors $MATH$, thus transforming the original, probably highly-dimensional, input to vectors in a K-dimensional space $MATH$.
Neural networks
The standard softmax function is often used in the final layer of a neural network-based classifier. Such networks are commonly trained under a log loss (or cross-entropy) regime, giving a non-linear variant of multinomial logistic regression.
Since the function maps a vector and a specific index $MATH$ to a real value, the derivative needs to take the index into account:
This expression is symmetrical in the indexes $MATH$ and thus may also be expressed as
Here, the Kronecker delta is used for simplicity (cf. the derivative of a sigmoid function, being expressed via the function itself). 
In order to achieve stable numerical computations of the derivative, one often subtracts a constant from the input vector. In theory, this does not change the output, and neither the derivative. But it is more stable as it can control explicitly the largest value computed in each exponent. 
If the function is scaled with the parameter $MATH$, then these expressions must be multiplied by $MATH$.
See multinomial logit for a probability model which uses the softmax activation function.
Reinforcement learning
In the field of reinforcement learning, a softmax function can be used to convert values into action probabilities. The function commonly used is:
where the action value $MATH$ corresponds to the expected reward of following action a and $MATH$ is called a temperature parameter (in allusion to statistical mechanics). For high temperatures ($MATH$), all actions have nearly the same probability and the lower the temperature, the more expected rewards affect the probability. For a low temperature ($MATH$), the probability of the action with the highest expected reward tends to 1.
Computational complexity and remedies
In neural network applications, the number K of possible outcomes is often large, e.g. in case of neural language models that predict the most likely outcome out of a vocabulary which might contain millions of possible words. This can make the calculations for the softmax layer (i.e. the matrix multiplications to determine the $MATH$, followed by the application of the softmax function itself) computationally expensive. What's more, the gradient descent backpropagation method for training such a neural network involves calculating the softmax for every training example, and the number of training examples can also become large. The computational effort for the softmax became a major limiting factor in the development of larger neural language models, motivating various remedies to reduce training times.
Approaches that reorganize the softmax layer for more efficient calculation include the hierarchical softmax and the differentiated softmax. The hierarchical softmax (introduced by Morin and Bengio in 2005) uses a binary tree structure where the outcomes (vocabulary words) are the leaves and the intermediate nodes are suitably selected "classes" of outcomes, forming latent variables. The desired probability (softmax value) of a leaf (outcome) can then be calculated as the product of the probabilities of all nodes on the path from the root to that leaf. Ideally, when the tree is balanced, this would reduce the computational complexity from $MATH$ to $MATH$. In practice, results depend on choosing a good strategy for clustering the outcomes into classes. A Huffman tree was used for this in Google's word2vec models (introduced in 2013) to achieve scalability.
A second kind of remedies is based on approximating the softmax (during training) with modified loss functions that avoid the calculation of the full normalization factor. These include methods that restrict the normalization sum to a sample of outcomes (e.g. Importance Sampling, Target Sampling).
Mathematical properties
Geometrically the softmax function maps the vector space $MATH$ to the boundary of the standard $MATH$-simplex, cutting the dimension by one (the range is a $MATH$-dimensional simplex in $MATH$-dimensional space), due to the linear constraint that all output sum to 1 meaning it lies on a hyperplane.
Along the main diagonal $MATH$ softmax is just the uniform distribution on outputs, $MATH$: equal scores yield equal probabilities.
More generally, softmax is invariant under translation by the same value in each coordinate: adding $MATH$ to the inputs $MATH$ yields $MATH$, because it multiplies each exponent by the same factor, $MATH$ (because $MATH$), so the ratios do not change:
Geometrically, softmax is constant along diagonals: this is the dimension that is eliminated, and corresponds to the softmax output being independent of a translation in the input scores (a choice of 0 score). One can normalize input scores by assuming that the sum is zero (subtract the average: $MATH$ where $MATH$), and then the softmax takes the hyperplane of points that sum to zero, $MATH$, to the open simplex of positive values that sum to 1$MATH$, analogously to how the exponent takes 0 to 1, $MATH$ and is positive.
By contrast, softmax is not invariant under scaling. For instance, $MATH$ but $MATH$
The standard logistic function is the special case for a 1-dimensional axis in 2-dimensional space, say the x-axis in the (x, y) plane. One variable is fixed at 0 (say $MATH$), so $MATH$, and the other variable can vary, denote it $MATH$, so $MATH$ the standard logistic function, and $MATH$ its complement (meaning they add up to 1). The 1-dimensional input could alternatively be expressed as the line $MATH$, with outputs $MATH$ and $MATH$
The softmax function is also the gradient of the LogSumExp function, a smooth maximum:
where the LogSumExp function is defined as $MATH$.
History
The softmax function was used in statistical mechanics as the Boltzmann distribution in the foundational paper Boltzmann (1868), formalized and popularized in the influential textbook Gibbs (1902).
The use of the softmax in decision theory is credited to Luce (1959) harvtxt error: no target: CITEREFLuce1959 (help),: 1  who used the axiom of independence of irrelevant alternatives in rational choice theory to deduce the softmax in Luce's choice axiom for relative preferences.
In machine learning, the term "softmax" is credited to John S. Bridle in two 1989 conference papers, Bridle (1990a):: 1  and Bridle (1990b):
Example
If we take an input of [1, 2, 3, 4, 1, 2, 3], the softmax of that is [0.024, 0.064, 0.175, 0.475, 0.024, 0.064, 0.175]. The output has most of its weight where the "4" was in the original input. This is what the function is normally used for: to highlight the largest values and suppress values which are significantly below the maximum value. But note: softmax is not scale invariant, so if the input were [0.1, 0.2, 0.3, 0.4, 0.1, 0.2, 0.3] (which sums to 1.6) the softmax would be [0.125, 0.138, 0.153, 0.169, 0.125, 0.138, 0.153]. This shows that for values between 0 and 1 softmax, in fact, de-emphasizes the maximum value (note that 0.169 is not only less than 0.475, it is also less than the initial proportion of 0.4/1.6=0.25).
Computation of this example using Python code:
Here is an example of Julia code:
Here is an example of R code:
Here is an example of Elixir code:
Here is an example of Raku code:
See also
Notes