I²C
I2C (Inter-Integrated Circuit,  eye-squared-C), alternatively known as I2C or IIC, is a synchronous, multi-controller/multi-target (master/slave), packet switched, single-ended, serial communication bus invented in 1982 by Philips Semiconductors. It is widely used for attaching lower-speed peripheral ICs to processors and microcontrollers in short-distance, intra-board communication.
Several competitors, such as Siemens, NEC, Texas Instruments, STMicroelectronics, Motorola, Nordic Semiconductor and Intersil, have introduced compatible I2C products to the market since the mid-1990s.
System Management Bus (SMBus), defined by Intel in 1995, is a subset of I2C, defining a stricter usage. One purpose of SMBus is to promote robustness and interoperability. Accordingly, modern I2C systems incorporate some policies and rules from SMBus, sometimes supporting both I2C and SMBus, requiring only minimal reconfiguration either by commanding or output pin use.
Applications
I2C is appropriate for peripherals where simplicity and low manufacturing cost are more important than speed. Common applications of the I2C bus are:
A particular strength of I2C is the capability of a microcontroller to control a network of device chips with just two general-purpose I/O pins and software. Many other bus technologies used in similar applications, such as Serial Peripheral Interface Bus (SPI), require more pins and signals to connect multiple devices.
Design
I2C uses only two bidirectional open-collector or open-drain lines: serial data line (SDA) and serial clock line (SCL), pulled up with resistors. Typical voltages used are +5 V or +3.3 V, although systems with other voltages are permitted.
The I2C reference design has a 7-bit address space, with a rarely used 10-bit extension. Common I2C bus speeds are the 100 kbit/s standard mode and the 400 kbit/s fast mode. There is also a 10 kbit/s low-speed mode, but arbitrarily low clock frequencies are also allowed. Later revisions of I2C can host more nodes and run at faster speeds (400 kbit/s fast mode, 1 Mbit/s fast mode plus, 3.4 Mbit/s high-speed mode, and 5 Mbit/s ultra-fast mode). These speeds are more widely used on embedded systems than on PCs.
Note that the bit rates are quoted for the transfers between controller (master) and target (slave) without clock stretching or other hardware overhead. Protocol overheads include a target address and perhaps a register address within the target device, as well as per-byte ACK/NACK bits. Thus the actual transfer rate of user data is lower than those peak bit rates alone would imply. For example, if each interaction with a target inefficiently allows only 1 byte of data to be transferred, the data rate will be less than half the peak bit rate.
The number of nodes which can exist on a given I2C bus is limited by the address space and also by the total bus capacitance of 400 pF, which restricts practical communication distances to a few meters. The relatively high impedance and low noise immunity requires a common ground potential, which again restricts practical use to communication within the same PC board or small system of boards.
Reference design
The aforementioned reference design is a bus with a clock (SCL) and data (SDA) lines with 7-bit addressing. The bus has two roles for nodes, 
either controller (master) or target (slave):
The bus is a multi-controller bus, which means that any number of controller nodes can be present. Additionally, controller and target roles may be changed between messages (after a STOP is sent).
There may be four potential modes of operation for a given bus device, although most devices only use a single role and its two modes:
In addition to 0 and 1 data bits, the I2C bus allows special START and STOP signals which act as message delimiters and are distinct from the data bits. (This is in contrast to the start bits and stop bits used in asynchronous serial communication, which are distinguished from data bits only by their timing.)
The controller is initially in controller transmit mode by sending a START followed by the 7-bit address of the target it wishes to communicate with, which is finally followed by a single bit representing whether it wishes to write (0) to or read (1) from the target.
If the target exists on the bus then it will respond with an ACK bit (active low for acknowledged) for that address. The controller then continues in either transmit or receive mode (according to the read/write bit it sent), and the target continues in the complementary mode (receive or transmit, respectively).
The address and the data bytes are sent most significant bit first. The start condition is indicated by a high-to-low transition of SDA with SCL high; the stop condition is indicated by a low-to-high transition of SDA with SCL high. All other transitions of SDA take place with SCL low.
If the controller wishes to write to the target, then it repeatedly sends a byte with the target sending an ACK bit. (In this situation, the controller is in controller transmit mode, and the target is in target receive mode.)
If the controller wishes to read from the target, then it repeatedly receives a byte from the target, the controller sending an ACK bit after every byte except the last one. (In this situation, the controller is in controller receive mode, and the target is in target transmit mode.)
An I2C transaction may consist of multiple messages. The controller terminates a message with a STOP condition if this is the end of the transaction or it may send another START condition to retain control of the bus for another message (a "combined format" transaction).
Message protocols
I2C defines basic types of transactions, each of which begins with a START and ends with a STOP:
In a combined transaction, each read or write begins with a START and the target address. The START conditions after the first are also called repeated START bits. Repeated STARTs are not preceded by STOP conditions, which is how targets know that the next message is part of the same transaction.
Any given target will only respond to certain messages, as specified in its product documentation.
Pure I2C systems support arbitrary message structures. SMBus is restricted to nine of those structures, such as read word N and write word N, involving a single target. PMBus extends SMBus with a Group protocol, allowing multiple such SMBus transactions to be sent in one combined message. The terminating STOP indicates when those grouped actions should take effect. For example, one PMBus operation might reconfigure three power supplies (using three different I2C target addresses), and their new configurations would take effect at the same time: when they receive that STOP.
With only a few exceptions, neither I2C nor SMBus define message semantics, such as the meaning of data bytes in messages. Message semantics are otherwise product-specific. Those exceptions include messages addressed to the I2C general call address (0x00) or to the SMBus Alert Response Address; and messages involved in the SMBus Address Resolution Protocol (ARP) for dynamic address allocation and management.
In practice, most targets adopt request-response control models, where one or more bytes following a write command are treated as a command or address. Those bytes determine how subsequent written bytes are treated or how the target responds on subsequent reads. Most SMBus operations involve single-byte commands.
Messaging example: 24C32 EEPROM
One specific example is the 24C32 type EEPROM, which uses two request bytes that are called Address High and Address Low. (Accordingly, these EEPROMs are not usable by pure SMBus hosts, which support only single-byte commands or addresses.) These bytes are used for addressing bytes within the 32 kbit (or 4 kB) EEPROM address space. The same two-byte addressing is also used by larger EEPROMs, like the 24C512 which stores 512 kbits (or 64 kB). Writing data to and reading from these EEPROMs uses a simple protocol: the address is written, and then data is transferred until the end of the message. The data transfer part of the protocol can cause trouble on the SMBus, since the data bytes are not preceded by a count, and more than 32 bytes can be transferred at once. I2C EEPROMs smaller than 32 kbit, like the 2 kbit 24C02, are often used on the SMBus with inefficient single-byte data transfers to overcome this problem.
A single message writes to the EEPROM. After the START, the controller sends the chip's bus address with the direction bit clear (write), then sends the two-byte address of data within the EEPROM and then sends data bytes to be written starting at that address, followed by a STOP. When writing multiple bytes, all the bytes must be in the same 32-byte page. While it is busy saving those bytes to memory, the EEPROM will not respond to further I2C requests. (That is another incompatibility with SMBus: SMBus devices must always respond to their bus addresses.)
To read starting at a particular address in the EEPROM, a combined message is used. After a START, the controller first writes that chip's bus address with the direction bit clear (write) and then the two bytes of EEPROM data address. It then sends a (repeated) START and the EEPROM's bus address with the direction bit set (read). The EEPROM will then respond with the data bytes beginning at the specified EEPROM data address — a combined message: first a write, then a read. The controller issues an ACK after each read byte except the last byte, and then issues a STOP. The EEPROM increments the address after each data byte transferred; multi-byte reads can retrieve the entire contents of the EEPROM using one combined message.
Physical layer
At the physical layer, both SCL and SDA lines are an open-drain (MOSFET) or open-collector (BJT) bus design, thus a pull-up resistor is needed for each line. A logic "0" is output by pulling the line to ground, and a logic "1" is output by letting the line float (output high impedance) so that the pull-up resistor pulls it high. A line is never actively driven high. This wiring allows multiple nodes to connect to the bus without short circuits from signal contention. High-speed systems (and some others) may use a current source instead of a resistor to pull-up only SCL or both SCL and SDA, to accommodate higher bus capacitance and enable faster rise times.
An important consequence of this is that multiple nodes may be driving the lines simultaneously. If any node is driving the line low, it will be low. Nodes that are trying to transmit a logical one (i.e. letting the line float high) can detect this and conclude that another node is active at the same time.
When used on SCL, this is called clock stretching and is a flow-control mechanism for targets. When used on SDA, this is called arbitration and ensures that there is only one transmitter at a time.
When idle, both lines are high. To start a transaction, SDA is pulled low while SCL remains high. It is illegal: 14  to transmit a stop marker by releasing SDA to float high again (although such a "void message" is usually harmless), so the next step is to pull SCL low.
Except for the start and stop signals, the SDA line only changes while the clock is low; transmitting a data bit consists of pulsing the clock line high while holding the data line steady at the desired level.
While SCL is low, the transmitter (initially the controller) sets SDA to the desired value and (after a small delay to let the value propagate) lets SCL float high. The controller then waits for SCL to actually go high; this will be delayed by the finite rise time of the SCL signal (the RC time constant of the pull-up resistor and the parasitic capacitance of the bus) and may be additionally delayed by a target's clock stretching.
Once SCL is high, the controller waits a minimum time (4 μs for standard-speed I2C) to ensure that the receiver has seen the bit, then pulls it low again. This completes transmission of one bit.
After every 8 data bits in one direction, an "acknowledge" bit is transmitted in the other direction. The transmitter and receiver switch roles for one bit, and the original receiver transmits a single "0" bit (ACK) back. If the transmitter sees a "1" bit (NACK) instead, it learns that:
Only the SDA line changes direction during acknowledge bits; the SCL is always controlled by the controller.
After the acknowledge bit, the clock line is low and the controller may do one of three things:
Clock stretching using SCL
One of the more significant features of the I2C protocol is clock stretching. An addressed target device may hold the clock line (SCL) low after receiving (or sending) a byte, indicating that it is not yet ready to process more data. The controller that is communicating with the target may not finish the transmission of the current bit, but must wait until the clock line actually goes high. If the target is clock-stretching, the clock line will still be low (because the connections are open-drain). The same is true if a second, slower, controller tries to drive the clock at the same time. (If there is more than one controller, all but one of them will normally lose arbitration.)
The controller must wait until it observes the clock line going high, and an additional minimal time (4 μs for standard 100 kbit/s I2C) before pulling the clock low again.
Although the controller may also hold the SCL line low for as long as it desires (this is not allowed since Rev. 6 of the protocol – subsection 3.1.1), the term "clock stretching" is normally used only when targets do it. Although in theory any clock pulse may be stretched, generally it is the intervals before or after the acknowledgment bit which are used. For example, if the target is a microcontroller, its I2C interface could stretch the clock after each byte, until the software decides whether to send a positive acknowledgment or a NACK.
Clock stretching is the only time in I2C where the target drives SCL. Many targets do not need to clock stretch and thus treat SCL as strictly an input with no circuitry to drive it. Some controllers, such as those found inside custom ASICs may not support clock stretching; often these devices will be labeled as a "two-wire interface" and not I2C.
To ensure a minimal bus throughput, SMBus places limits on how far clocks may be stretched. Hosts and targets adhering to those limits cannot block access to the bus for more than a short time, which is not a guarantee made by pure I2C systems.
Arbitration using SDA
Every controller monitors the bus for start and stop bits and does not start a message while another controller is keeping the bus busy. However, two controllers may start transmission at about the same time; in this case, arbitration occurs. Target transmit mode can also be arbitrated, when a controller addresses multiple targets, but this is less common. In contrast to protocols (such as Ethernet) that use random back-off delays before issuing a retry, I2C has a deterministic arbitration policy. Each transmitter checks the level of the data line (SDA) and compares it with the levels it expects; if they do not match, that transmitter has lost arbitration and drops out of this protocol interaction.
If one transmitter sets SDA to 1 (not driving a signal) and a second transmitter sets it to 0 (pull to ground), the result is that the line is low. The first transmitter then observes that the level of the line is different from that expected and concludes that another node is transmitting. The first node to notice such a difference is the one that loses arbitration: it stops driving SDA. If it is a controller, it also stops driving SCL and waits for a STOP; then it may try to reissue its entire message. In the meantime, the other node has not noticed any difference between the expected and actual levels on SDA and therefore continues transmission. It can do so without problems because so far the signal has been exactly as it expected; no other transmitter has disturbed its message.
If the two controllers are sending a message to two different targets, the one sending the lower target address always "wins" arbitration in the address stage. Since the two controllers may send messages to the same target address, and addresses sometimes refer to multiple targets, arbitration must sometimes continue into the data stages.
Arbitration occurs very rarely, but is necessary for proper multi-controller support. As with clock stretching, not all devices support arbitration. Those that do, generally label themselves as supporting "multi-controller" communication.
One case which must be handled carefully in multi-controller I2C implementations is that of the controllers talking to each other. One controller may lose arbitration to an incoming message, and must change its role from controller to target in time to acknowledge its own address.
In the extremely rare case that two controllers simultaneously send identical messages, both will regard the communication as successful, but the target will only see one message. For this reason, when a target can be accessed by multiple controllers, every command recognized by the target either must be idempotent or must be guaranteed never to be issued by two controllers at the same time. (For example, a command which is issued by only one controller need not be idempotent, nor is it necessary for a specific command to be idempotent when some mutual exclusion mechanism ensures that only one controller can be caused to issue that command at any given time.)
Arbitration in SMBus
While I2C only arbitrates between controllers, SMBus uses arbitration in three additional contexts, where multiple targets respond to the controller, and one gets its message through.
Arbitration in PMBus
PMBus version 1.3 extends the SMBus alert response protocol in its "zone read" protocol. Targets may be grouped into "zones", and all targets in a zone may be addressed to respond, with their responses masked (omitting unwanted information), inverted (so wanted information is sent as 0 bits, which win arbitration), or reordered (so the most significant information is sent first). Arbitration ensures that the highest priority response is the one first returned to the controller.
PMBus reserves I2C addresses 0x28 and 0x37 for zone reads and writes, respectively.
Differences between modes
There are several possible operating modes for I2C communication. All are compatible in that the 100 kbit/s standard mode may always be used, but combining devices of different capabilities on the same bus can cause issues, as follows:
Some of the vendors provide a so called non-standard Turbo mode with a speed up to 1.4 Mbit/s.
In all modes, the clock frequency is controlled by the controller(s), and a longer-than-normal bus may be operated at a slower-than-nominal speed by underclocking.
Circuit interconnections
I2C is popular for interfacing peripheral circuits to prototyping systems, such as the Arduino and Raspberry Pi. I2C does not employ a standardized connector, however, board designers have created various wiring schemes for I2C interconnections. To minimize the possible damage due to plugging 0.1-inch headers in backwards, some developers have suggested using alternating signal and power connections of the following wiring schemes: (GND, SCL, VCC, SDA) or (VCC, SDA, GND, SCL).
The vast majority of applications use I2C in the way it was originally designed—peripheral ICs directly wired to a processor on the same printed circuit board, and therefore over relatively short distances of less than 1 foot (30 cm), without a connector. However using a differential driver, an alternate version of I2C can communicate up to 20 meters (possibly over 100 meters) over CAT5 or other cable.
Several standard connectors carry I2C signals. For example, the UEXT connector carries I2C;
the 10-pin iPack connector carries I2C; the 6P6C Lego Mindstorms NXT connector carries I2C; a few people use the 8P8C connectors and CAT5 cable normally used for Ethernet physical layer to instead carry differential-encoded I2C signals or boosted single-ended I2C signals; and every HDMI and most DVI and VGA connectors carry DDC2 data over I2C.
Buffering and multiplexing
When there are many I2C devices in a system, there can be a need to include bus buffers or multiplexers to split large bus segments into smaller ones. This can be necessary to keep the capacitance of a bus segment below the allowable value or to allow multiple devices with the same address to be separated by a multiplexer. Many types of multiplexers and buffers exist and all must take into account the fact that I2C lines are specified to be bidirectional. Multiplexers can be implemented with analog switches, which can tie one segment to another. Analog switches maintain the bidirectional nature of the lines but do not isolate the capacitance of one segment from another or provide buffering capability.
Buffers can be used to isolate capacitance on one segment from another and/or allow I2C to be sent over longer cables or traces. Buffers for bi-directional lines such as I2C must use one of several schemes for preventing latch-up. I2C is open-drain, so buffers must drive a low on one side when they see a low on the other. One method for preventing latch-up is for a buffer to have carefully selected input and output levels such that the output level of its driver is higher than its input threshold, preventing it from triggering itself. For example, a buffer may have an input threshold of 0.4 V for detecting a low, but an output low level of 0.5 V. This method requires that all other devices on the bus have thresholds which are compatible and often means that multiple buffers implementing this scheme cannot be put in series with one another.
Alternatively, other types of buffers exist that implement current amplifiers or keep track of the state (i.e. which side drove the bus low) to prevent latch-up. The state method typically means that an unintended pulse is created during a hand-off when one side is driving the bus low, then the other drives it low, then the first side releases (this is common during an I2C acknowledgement).
Sharing SCL between multiple buses
When having a single controller, it is possible to have multiple I2C buses share the same SCL line. The packets on each bus are either sent one after the other or at the same time. This is possible, because the communication on each bus can be subdivided in alternating short periods with high SCL followed by short periods with low SCL. And the clock can be stretched, if one bus needs more time in one state.
Advantages are using targets devices with the same address at the same time and saving connections or a faster throughput by using several data lines at the same time.
Line state table
These tables show the various atomic states and bit operations that may occur during an I2C message.
Reserved addresses in 7-bit address space
Two groups of addresses are reserved for special functions:
SMBus reserves some additional addresses. In particular, 0001 000 is reserved for the SMBus host, which may be used by controller-capable devices, 0001 100 is the "SMBus alert response address" which is polled by the host after an out-of-band interrupt, and 1100 001 is the default address which is initially used by devices capable of dynamic address assignment.
This leaves a total of 107 unreserved 7-bit addresses in common between I2C, SMBus, and PMBus.


Non-reserved addresses in 7-bit address space
Although MSB 1111 is reserved for Device ID and 10-bit target (slave) addressing, it is also used by VESA DDC display dependent devices such as pointing devices.
Transaction format
An I2C transaction consists of one or more messages. Each message begins with a start symbol, and the transaction ends with a stop symbol. Start symbols after the first, which begin a message but not a transaction, are referred to as repeated start symbols.
Each message is a read or a write. A transaction consisting of a single message is called either a read or a write transaction. A transaction consisting of multiple messages is called a combined transaction. The most common form of the latter is a write message providing intra-device address information, followed by a read message.
Many I2C devices do not distinguish between a combined transaction and the same messages sent as separate transactions, but not all. The device ID protocol requires a single transaction; targets are forbidden from responding if they observe a stop symbol. Configuration, calibration or self-test modes which cause the target to respond unusually are also often automatically terminated at the end of a transaction.
Timing diagram
In order to avoid false marker detection, there is a minimum delay between the SCL falling edge and changing SDA, and between changing SDA and the SCL rising edge. Note that an I2C message containing n data bits (including acknowledges) contains n + 1 clock pulses.
Software Design
I2C lends itself to a "bus driver" software design. Software for attached devices is written to call a "bus driver" that handles the actual low-level I2C hardware. This permits the driver code for attached devices to port easily to other hardware, including a bit-banging design.
Example of bit-banging the I2C protocol
Below is an example of bit-banging the I2C protocol as an I2C controller (master). The example is written in pseudo C. It illustrates all of the I2C features described before (clock stretching, arbitration, start/stop bit, ack/nack).
Operating system support
Development tools
When developing or troubleshooting systems using I2C, visibility at the level of hardware signals can be important.
Host adapters
There are a number of I2C host adapter hardware solutions for making a I2C controller or target connection to host computers, running Linux, Mac or Windows. Most options are USB-to-I2C adapters. Not all of them require proprietary drivers or APIs.
Protocol analyzers
I2C protocol analyzers are tools that sample an I2C bus and decode the electrical signals to provide a higher-level view of the data being transmitted on the bus.
Logic analyzers
When developing and/or troubleshooting the I2C bus, examination of hardware signals can be very important. Logic analyzers are tools that collect, analyze, decode, and store signals, so people can view the high-speed waveforms at their leisure. Logic analyzers display time stamps of each signal level change, which can help find protocol problems. Most logic analyzers have the capability to decode bus signals into high-level protocol data and show ASCII data.
Limitations
On low-power systems, the pull-up resistors can use more power than the entire rest of the design combined. On these, the resistors are often powered by a switchable voltage source, such as a DIO from a microcontroller. The pull-ups also limit the speed of the bus and have a small additional cost. Therefore, some designers are turning to other serial buses, e.g. I3C or SPI, that do not need pull-ups.
The assignment of target addresses is a weakness of I2C. Seven bits is too few to prevent address collisions between the many thousands of available devices. What alleviates the issue of address collisions between different vendors and also allows to connect to several identical devices is that manufacturers dedicate pins that can be used to set the target address to one of a few address options per device. Two or three pins is typical, and with many devices, there are three or more wiring options per address pin.
10-bit I2C addresses are not yet widely used, and many host operating systems do not support them. Neither is the complex SMBus "ARP" scheme for dynamically assigning addresses (other than for PCI cards with SMBus presence, for which it is required).
Automatic bus configuration is a related issue. A given address may be used by a number of different protocol-incompatible devices in various systems, and hardly any device types can be detected at runtime. For example, 0x51 may be used by a 24LC02 or 24C32 EEPROM, with incompatible addressing; or by a PCF8563 RTC, which cannot reliably be distinguished from either (without changing device state, which might not be allowed). The only reliable configuration mechanisms available to hosts involve out-of-band mechanisms such as tables provided by system firmware, which list the available devices. Again, this issue can partially be addressed by ARP in SMBus systems, especially when vendor and product identifiers are used; but that has not really caught on. The Rev. 3 version of the I2C specification adds a device ID mechanism.
I2C supports a limited range of speeds. Hosts supporting the multi-megabit speeds are rare. Support for the Fm+ 1 Mbit/s speed is more widespread, since its electronics are simple variants of what is used at lower speeds. Many devices do not support the 400 kbit/s speed (in part because SMBus does not yet support it). I2C nodes implemented in software (instead of dedicated hardware) may not even support the 100 kbit/s speed; so the whole range defined in the specification is rarely usable. All devices must at least partially support the highest speed used or they may spuriously detect their device address.
Devices are allowed to stretch clock cycles to suit their particular needs, which can starve bandwidth needed by faster devices and increase latencies when talking to other device addresses. Bus capacitance also places a limit on the transfer speed, especially when current sources are not used to decrease signal rise times.
Because I2C is a shared bus, there is the potential for any device to have a fault and hang the entire bus. For example, if any device holds the SDA or SCL line low, it prevents the controller from sending START or STOP commands to reset the bus. Thus it is common for designs to include a reset signal that provides an external method of resetting the bus devices. However many devices do not have a dedicated reset pin, forcing the designer to put in circuitry to allow devices to be power-cycled if they need to be reset.
Because of these limits (address management, bus configuration, potential faults, speed), few I2C bus segments have even a dozen devices. It is common for systems to have several such segments. One might be dedicated to use with high-speed devices, for low-latency power management. Another might be used to control a few devices where latency and throughput are not important issues; yet another segment might be used only to read EEPROM chips describing add-on cards (such as the SPD standard used with DRAM sticks).
Derivative technologies
I2C is the basis for the ACCESS.bus, the VESA Display Data Channel (DDC) interface, the System Management Bus (SMBus), Power Management Bus (PMBus) and the Intelligent Platform Management Bus (IPMB, one of the protocols of IPMI). These variants have differences in voltage and clock frequency ranges, and may have interrupt lines.
High-availability systems (AdvancedTCA, MicroTCA) use 2-way redundant I2C for shelf management. Multi-controller I2C capability is a requirement in these systems.
TWI (Two-Wire Interface) or TWSI (Two-Wire Serial Interface) is essentially the same bus implemented on various system-on-chip processors from Atmel and other vendors. Vendors use the name TWI, even though I2C is not a registered trademark as of 2014-11-07. Trademark protection only exists for the respective logo (see upper right corner), and patents on I2C have now lapsed. According to Microchip Technology, TWI and I2C have a few differences. One of them is that TWI does not support START byte.
In some cases, use of the term "two-wire interface" indicates incomplete implementation of the I2C specification. Not supporting arbitration or clock stretching is one common limitation, which is still useful for a single controller communicating with simple targets that never stretch the clock.
MIPI I3C sensor interface standard (I3C) is a development of I2C, under development in 2017.
See also
References
Further reading