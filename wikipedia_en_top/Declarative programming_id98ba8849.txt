Declarative programming
In computer science, declarative programming is a programming paradigm—a style of building the structure and elements of computer programs—that expresses the logic of a computation without describing its control flow.
Many languages that apply this style attempt to minimize or eliminate side effects by describing what the program must accomplish in terms of the problem domain, rather than describe how to accomplish it as a sequence of the programming language primitives (the how being left up to the language's implementation). This is in contrast with imperative programming, which implements algorithms in explicit steps.
Declarative programming often considers programs as theories of a formal logic, and computations as deductions in that logic space. Declarative programming may greatly simplify writing parallel programs.
Common declarative languages include those of database query languages (e.g., SQL, XQuery), regular expressions, logic programming, functional programming, and configuration management systems.
Definition
Declarative programming is often defined as any style of programming that is not imperative. A number of other common definitions attempt to define it by simply contrasting it with imperative programming. For example:
These definitions overlap substantially.
Declarative programming is a non-imperative style of programming in which programs describe their desired results without explicitly listing commands or steps that must be performed. Functional and logical programming languages are characterized by a declarative programming style. In logical programming languages, programs consist of logical statements, and the program executes by searching for proofs of the statements.
In a pure functional language, such as Haskell, all functions are without side effects, and state changes are only represented as functions that transform the state, which is explicitly represented as a first-class object in the program. Although pure functional languages are non-imperative, they often provide a facility for describing the effect of a function as a series of steps. Other functional languages, such as Lisp, OCaml and Erlang, support a mixture of procedural and functional programming.
Some logical programming languages, such as Prolog, and database query languages, such as SQL, while declarative in principle, also support a procedural style of programming.
Subparadigms
Declarative programming is an umbrella term that includes a number of better-known programming paradigms.
Constraint programming
Constraint programming states relations between variables in the form of constraints that specify the properties of the target solution. The set of constraints is solved by giving a value to each variable so that the solution is consistent with the maximum number of constraints. Constraint programming often complements other paradigms: functional, logical, or even imperative programming.
Domain-specific languages
Well-known examples of declarative domain-specific languages (DSLs) include the yacc parser generator input language, QML, the Make build specification language, Puppet's configuration management language, regular expressions, and a subset of SQL (SELECT queries, for example). DSLs have the advantage of being useful while not necessarily needing to be Turing-complete, which makes it easier for a language to be purely declarative.
Many markup languages such as HTML, MXML, XAML, XSLT or other user-interface markup languages are often declarative. HTML, for example, only describes what should appear on a webpage - it specifies neither control flow for rendering a page nor the page's possible interactions with a user.
As of 2013, some software systems combine traditional user-interface markup languages (such as HTML) with declarative markup that defines what (but not how) the back-end server systems should do to support the declared interface. Such systems, typically using a domain-specific XML namespace, may include abstractions of SQL database syntax or parameterized calls to web services using representational state transfer (REST) and SOAP.
Functional programming
Functional programming languages such as Haskell, Scheme, and ML evaluate expressions via function application. Unlike the related but more imperative paradigm of Procedural programming, functional programming places little emphasis on explicit sequencing. For example, in Scheme, the order of evaluation of many kinds of sub-expressions is undefined or implicit. Instead, computations are characterised by various kinds of recursive higher-order function application and composition, and as such can be regarded simply as a set of mappings between domains and codomains. Many functional languages, including most of those in the ML and Lisp families, are not purely functional, and thus allow the introduction of stateful effects in programs, though this is typically avoided when possible.
Hybrid languages
Makefiles, for example, specify dependencies in a declarative fashion, but include an imperative list of actions to take as well. Similarly, yacc specifies a context free grammar declaratively, but includes code snippets from a host language, which is usually imperative (such as C).
Logic programming
Logic programming languages such as Prolog state and query relations. The specifics of how these queries are answered is up to the implementation and its theorem prover, but typically take the form of some sort of unification. Like functional programming, many logic programming languages permit side effects, and as a result are not strictly declarative.
Modeling
Models, or mathematical representations, of physical systems may be implemented in computer code that is declarative. The code contains a number of equations, not imperative assignments, that describe ("declare") the behavioral relationships. When a model is expressed in this formalism, a computer is able to perform algebraic manipulations to best formulate the solution algorithm.  The mathematical causality is typically imposed at the boundaries of the physical system, while the behavioral description of the system itself is declarative or acausal. Declarative modeling languages and environments include Analytica, Modelica and Simile.
Examples
Lisp
Lisp (1958) stands for "LISt Processor." It is tailored to process lists. A data structure is formed by building lists of lists. In memory, this forms a tree data structure. Internally, the tree structure of typical Lisp data lends itself nicely to processing with recursive functions. The syntax to build a tree is to enclose the whitespace-separated elements within parenthesis. The following is a list of three elements. The first two elements are themselves lists of two elements each:
((A B) (HELLO WORLD) 94)
Lisp has functions to extract and reconstruct elements. The function car (sometimes called first) returns the first element in the list. The function cdr (sometimes called rest) returns a list containing everything but the first element. The function cons returns a list that is the concatenation of two data elements. Therefore, the following expression will return the list X:
(cons (car x) (cdr x))
The above code returns a copy of the list X. As is typical in functional languages, operations in Lisp often copy data when asked to produce new data from old. The tree structure of Lisp data facilitates this as well: a new structure made from pre-existing data shares as much of its internal structure with its antecedents as possible, with new additions stored as branches of the tree, and references to the original structure under its original name will return exactly that and no more.
One drawback of Lisp is when many functions are nested, the parentheses may look confusing. Modern Lisp environments help ensure parenthesis match. As an aside, Lisp does support the imperative language operations of the assignment statement and goto loops. Also, Lisp is not concerned with the datatype of the elements at compile time. Instead, it assigns the datatypes at runtime. This may lead to programming errors not being detected early in the development process. To counteract this, Lisp development is typically carried out in an extremely incremental manner, with functions and higher-order functions built up and tested live during development. Additionally, through the use of macros, which are Lisp functions that operate upon Lisp programs as data structures, type checking may be performed discretionally at any point the programmer wishes.
Writing large, reliable, and readable Lisp programs requires forethought. If properly planned, the program may be much shorter than an equivalent imperative language program. Lisp is widely used in artificial intelligence. However, its usage has been accepted only because it has imperative language operations, making unintended side-effects possible.
ML
ML (1973) stands for "Meta Language." ML is statically typed, and function arguments and return types may be annotated.
ML is not parenthesis-eccentric like Lisp. The following is an application of times_10:
It returns "20 : int", that is, 20, a value of type int. 
Like Lisp, ML is tailored to process lists, though all elements of a list must be the same type.
Prolog
Prolog (1972) stands for "PROgramming in LOGic." It was designed to process natural languages. The building blocks of a Prolog program are objects and their relationships to other objects. Objects are built by stating true facts about them.
Set theory facts are formed by assigning objects to sets. The syntax is setName(object).
Adjective facts are formed using adjective(object).
Relationships are formed using multiple items inside the parentheses. In our example we have verb(object,object) and verb(adjective,adjective).
After all the facts and relationships are entered, then a question can be asked:
Prolog's usage has expanded to become a goal-oriented language. In a goal-oriented application, the goal is defined by providing a list of subgoals. Then each subgoal is defined by further providing a list of its subgoals, etc. If a path of subgoals fails to find a solution, then that subgoal is backtracked and another path is systematically attempted. Practical applications include solving the shortest path problem and producing family trees.