RISC-V
RISC-V (pronounced "risk-five": 1  where five refers to the number of generations of RISC architecture that were developed at the University of California, Berkeley since 1981) is an open standard instruction set architecture (ISA) based on established RISC principles. Unlike most other ISA designs, RISC-V is provided under open source licenses that do not require fees to use. A number of companies are offering or have announced RISC-V hardware, open source operating systems with RISC-V support are available, and the instruction set is supported in several popular software toolchains.
As a RISC architecture, the RISC-V ISA is a load–store architecture. Its floating-point instructions use IEEE 754 floating-point. Notable features of the RISC-V ISA include instruction bit field locations chosen to simplify the use of multiplexers in a CPU,: 17  a design that is architecturally neutral, and most-significant bits of immediate values placed at a fixed location to speed sign extension.: 17 
The instruction set is designed for a wide range of uses. The base instruction set has a fixed length of 32-bit naturally aligned instructions, and the ISA supports variable length extensions where each instruction can be any number of 16-bit parcels in length.: 7–10  Subsets support small embedded systems, personal computers, supercomputers with vector processors, and warehouse-scale 19 inch rack-mounted parallel computers.
The instruction set specification defines 32-bit and 64-bit address space variants. The specification includes a description of a 128-bit flat address space variant, as an extrapolation of 32 and 64 bit variants, but the 128-bit ISA remains "not frozen" intentionally, because there is yet so little practical experience with such large memory systems.: 41 
The project began in 2010 at the University of California, Berkeley, but now many current contributors are volunteers not affiliated with the university. Unlike other academic designs which are typically optimized only for simplicity of exposition, the designers intended that the RISC-V instruction set be usable for practical computers.  As of June 2019, version 2.2 of the user-space ISA and version 1.11 of the privileged ISA are frozen, permitting software and hardware development to proceed. The user-space ISA, now renamed the Unprivileged ISA, was updated, ratified and frozen as version 20191213. An external debug specification is available as a draft, version 0.13.2.
Rationale
CPU design requires design expertise in several specialties: electronic digital logic, compilers, and operating systems. To cover the costs of such a team, commercial vendors of computer designs, such as Arm Ltd., Cortus and MIPS Technologies, charge royalties for the use of their designs, patents and copyrights. They also often require non-disclosure agreements before releasing documents that describe their designs' detailed advantages. In many cases, they never describe the reasons for their design choices.
RISC-V was begun with a goal to make a practical ISA that was open-sourced, usable academically, and deployable in any hardware or software design without royalties.: 1  Also, justifying rationales for each design decision of the project are explained, at least in broad terms. The RISC-V authors are academics who have substantial experience in computer design, and the RISC-V ISA is a direct development from a series of academic computer-design projects, especially Berkeley RISC. RISC-V was originated in part to aid all such projects.: 1 
To build a large, continuing community of users and thereby accumulate designs and software, the RISC-V ISA designers intentionally support a wide variety of practical use cases: compact, performance, and low-power real-world implementations: 1–2, 153–154  without over-architecting for a given microarchitecture.: 1   The requirements of a large base of contributors is part of the reason why RISC-V was engineered to address many possible uses.
The designers' primary assertion is  that the instruction set is the key interface in a computer as it is situated at the interface between the hardware and the software. If a good instruction set were open and available for use by all, then it can dramatically reduce the cost of software by enabling far more reuse. It should also trigger increased competition among hardware providers, who can then devote more resources toward design and less for software support.
The designers maintain that new principles are becoming rare in instruction set design, as the most successful designs of the last forty years have grown increasingly similar. Of those that failed, most did so because their sponsoring companies were financially unsuccessful, not because the instruction sets were technically poor. Thus, a well-designed open instruction set designed using well-established principles should attract long-term support by many vendors.
RISC-V also encourages academic usage. The simplicity of the integer subset permits basic student exercises, and is a simple enough ISA to enable software to control research machines. The variable-length ISA provides room for instruction set extensions for both student exercises and research,: 7  and the separated privileged instruction set permits research in operating system support without redesigning compilers. RISC-V's open intellectual property paradigm allows derivative designs to be published, reused, and modified.
History
The term RISC dates from about 1980. Before then, there was some knowledge that simpler computers can be effective (e.g., John Cocke at IBM Research), but the design principles were not widely described. Simple, effective computers have always been of academic interest, and resulted in the RISC instruction set DLX for the first edition of Computer Architecture: A Quantitative Approach in 1990 of which David Patterson was a co-author, and he later participated in the RISC-V origination.  DLX was intended for educational use; academics and hobbyists implemented it using field-programmable gate arrays, but it was never truly intended for commercial deployment.  ARM CPUs, versions 2 and earlier, had a public-domain instruction set and are still supported by the GNU Compiler Collection (GCC), a popular free-software compiler. Three open-source cores exist for this ISA, but were never manufactured. OpenRISC is an open-source ISA based on DLX, with associated RISC designs, and is fully supported with GCC and Linux implementations, although it too has few commercial implementations.
Krste Asanović at the University of California, Berkeley, had a research requirement for an open-source computer system, and in 2010, he decided to develop and publish one in a "short, three-month project over the summer" with several of his graduate students. The plan was to aid both academic and industrial users. David Patterson at Berkeley joined the collaboration as he was the originator of the Berkeley RISC, and the RISC-V is the eponymous fifth generation of his long series of cooperative RISC-based research projects. At this stage, students provided initial software, simulations, and CPU designs.
The RISC-V authors and their institution originally sourced the ISA documents and several CPU designs under BSD licenses, which allow derivative works—such as RISC-V chip designs—to be either open and free, or closed and proprietary. The ISA specification itself (i.e., the encoding of the instruction set) was published in 2011 as open source, with all rights reserved. The actual technical report (an expression of the specification) was later placed under a Creative Commons license to permit enhancement by external contributors through the RISC-V Foundation, and later RISC-V International.
A full history of RISC-V has been published on the RISC-V International website.
RISC-V Foundation and RISC-V International
Commercial users require an ISA to be stable before they can use it in a product that may last many years. To address this issue, the RISC-V Foundation was formed in 2015 to own, maintain, and publish intellectual property related to RISC-V's definition. The original authors and owners have surrendered their rights to the foundation. The foundation is led by CEO Calista Redmond, who took on the role in 2019 after leading open infrastructure projects at IBM.
In November 2019, the RISC-V Foundation announced that it would relocate to Switzerland, citing concerns over U.S. trade regulations. As of March 2020, the organization was named RISC-V International, a Swiss nonprofit business association.
As of 2019, RISC-V International freely publishes the documents defining RISC-V and permits unrestricted use of the ISA for design of software and hardware. However, only members of RISC-V International can vote to approve changes, and only member organizations use the trademarked compatibility logo.
Awards
Design
ISA base and extensions
RISC-V has a modular design, consisting of alternative base parts, with added optional extensions. The ISA base and its extensions are developed in a collective effort between industry, the research community and educational institutions. The base specifies instructions (and their encoding), control flow, registers (and their sizes), memory and addressing, logic (i.e., integer) manipulation, and ancillaries. The base alone can implement a simplified general-purpose computer, with full software support, including a general-purpose compiler.
The standard extensions are specified to work with all of the standard bases, and with each other without conflict.
Many RISC-V computers might implement the compressed instructions extension to reduce power consumption, code size, and memory use.: 97–99  There are also future plans to support hypervisors and virtualization.
Together with a supervisor instruction set extension, S, an RVGC defines all instructions needed to conveniently support a general purpose operating system.
To tame the combinations of functions that may be implemented, a nomenclature is defined to specify them in Chapter 27 of the current ratified Unprivileged ISA Specification. The instruction set base is specified first, coding for RISC-V, the register bit-width, and the variant; e.g., RV64I or RV32E. Then follows letters specifying implemented extensions, in the order of the above table. Each letter may be followed by a major optionally followed by "p" and a minor option number. It defaults to 0 if a minor version number is absent, and 1.0 if all of a version number is absent. Thus RV64IMAFD may be written as RV64I1p0M1p0A1p0F1p0D1p0 or more simply as RV64I1M1A1F1D1. Underscores may be used between extensions for readability, for example RV32I2_M2_A2.
The base, extended integer and floating point calculations, and synchronization primitives for multi-core computing, the base and extensions MAFD, are considered to be necessary for general-purpose computation, and thus have the shorthand, G.
A small 32-bit computer for an embedded system might be RV32EC. A large 64-bit computer might be RV64GC; i.e., shorthand for RV64IMAFDCZicsr_Zifencei.
With the growth in the number of extensions, the standard now provides for extensions to be named by a single "Z" followed by an alphabetical name and an optional version number. For example, Zifencei names the instruction-fetch extension. Zifencei2 and Zifencei2p0 name version 2.0 of the same.  The  first letter following the "Z" by convention indicates the most closely related alphabetical extension category, IMAFDQLCBJTPVN.  Thus the Zam extension for misaligned atomics relates to the "A" standard extension. Unlike single character extensions, Z extensions must be separated by underscores, grouped by category and then alphabetically within each category.  For example, Zicsr_Zifencei_Zam.
Extensions specific to supervisor privilege level are named in the same way using "S" for prefix. Extensions specific to hypervisor level are named using "H" for prefix. Machine level extensions are prefixed with the three letters "Zxm".  Supervisor, hypervisor and machine level instruction set extensions are named after less privileged extensions.
RISC-V developers may create their own non-standard instruction set extensions. These follow the "Z" naming convention, but with "X" as the prefix. They should be specified after all standard extensions, and if multiple non-standard extensions are listed, they should be listed alphabetically.
Profiles and Platforms
Profiles and Platforms for standard ISA choice lists are under discussion.
Register sets
RISC-V has 32 (or 16 in the embedded variant) integer registers, and, when the floating-point extension is implemented, separate 32 floating-point registers. Except for memory access instructions, instructions address only registers.
The first integer register is a zero register, and the remainder are general-purpose registers. A store to the zero register has no effect, and a read always provides 0. Using the zero register as a placeholder makes for a simpler instruction set.
move rx to ry becomes add immediate 0 to rx and store in ry.: 18 
Control and status registers exist, but user-mode programs can access only those used for performance measurement and floating-point management.
No instructions exist to save and restore multiple registers. Those were thought to be needless, too complex, and perhaps too slow.
Memory access
Like many RISC designs, RISC-V is a load–store architecture: instructions address only registers, with load and store instructions conveying data to and from memory.
Most load and store instructions include a 12-bit offset and two register identifiers. One register is the base register. The other register is the source (for a store) or destination (for a load).
The offset is added to a base register to get the address.: 24  Forming the address as a base register plus offset allows single instructions to access data structures. For example, if the base register points to the top of a stack, single instructions can access a subroutine's local variables in the stack. Likewise the load and store instructions can access a record-style structure or a memory-mapped I/O device. Using the constant zero register as a base address allows single instructions to access memory near address zero.
Memory is addressed as 8-bit bytes, with instructions being in little-endian order,: 9–10  and with data being in the byte order defined by the execution environment interface in which code is running.: 3, 9–10, 24  Words, up to the register size, can be accessed with the load and store instructions.
RISC-V was originally specified as little-endian to resemble other familiar, successful computers, for example, x86.: 9–10  This also reduces a CPU's complexity and costs slightly less because it reads all sizes of words in the same order. For example, the RISC-V instruction set decodes starting at the lowest-addressed byte of the instruction. Big-endian and bi-endian variants were defined for support of legacy code bases that assume big-endian alignment.: 9–10 
An execution environment interface may allow accessed memory addresses not to be aligned to their word width, but accesses to aligned addresses may be faster; for example, simple CPUs may implement unaligned accesses with slow software emulation driven from an alignment failure interrupt.: 3, 24–25 
Like many RISC instruction sets (and some complex instruction set computer (CISC) instruction sets, such as x86 and IBM System/360 and its successors through z/Architecture), RISC-V lacks address-modes that write back to the registers. For example, it does not auto-increment.: 24 
RISC-V manages memory systems that are shared between CPUs or threads by ensuring a thread of execution always sees its memory operations in the programmed order. But between threads and I/O devices, RISC-V is simplified: it doesn't guarantee the order of memory operations, except by specific instructions, such as fence.
A fence instruction guarantees that the results of predecessor operations are visible to successor operations of other threads or I/O devices. fence can guarantee the order of combinations of both memory and memory-mapped I/O operations. E.g. it can separate memory read and write operations, without affecting I/O operations. Or, if a system can operate I/O devices in parallel with memory, fence doesn't force them to wait for each other. One CPU with one thread may decode fence as nop.
Some RISC CPUs (such as MIPS, PowerPC, DLX, and Berkeley's RISC-I) place 16 bits of offset in the loads and stores. They set the upper 16 bits by a load upper word instruction. This permits upper-halfword values to be set easily, without shifting bits. However, most use of the upper half-word instruction makes 32-bit constants, like addresses. RISC-V uses a SPARC-like combination of 12-bit offsets and 20-bit set upper instructions. The smaller 12-bit offset helps compact, 32-bit load and store instructions select two of 32 registers yet still have enough bits to support RISC-V's variable-length instruction coding.: 16 
Immediates
RISC-V handles 32-bit constants and addresses with instructions that set the upper 20 bits of a 32-bit register. Load upper immediate lui loads 20 bits into bits 31 through 12. Then a second instruction such as addi can set the bottom 12 bits. Small numbers or addresses can be formed by using the zero register instead of lui.
This method is extended to permit position-independent code by adding an instruction, auipc that generates 20 upper address bits by adding an offset to the program counter and storing the result into a base register. This permits a program to generate 32-bit addresses that are relative to the program counter.
The base register can often be used as-is with the 12-bit offsets of the loads and stores. If needed, addi can set the lower 12 bits of a register. In 64-bit and 128-bit ISAs,lui and auipc sign-extend the result to get the larger address.: 37 
Some fast CPUs may interpret combinations of instructions as single fused instructions. lui or auipc are good candidates to fuse with jalr, addi, loads or stores.
Subroutine calls, jumps, and branches
RISC-V's subroutine call jal (jump and link) places its return address in a register. This is faster in many computer designs, because it saves a memory access compared to systems that push a return address directly on a stack in memory. jal has a 20-bit signed (two's complement) offset. The offset is multiplied by 2, then added to the PC to generate a relative address to a 32-bit instruction. If the result is not at a 32-bit address (i.e., evenly divisible by 4), the CPU may force an exception.: Section 2.5 
RISC-V CPUs jump to calculated addresses using a jump and link-register, jalr instruction. jalr is similar to jal, but gets its destination address by adding a 12-bit offset to a base register. (In contrast,jal adds a larger 20-bit offset to the PC.)
jalr's bit format is like the register-relative loads and stores. Like them, jalr can be used with the instructions that set the upper 20 bits of a base register to make 32-bit branches, either to an absolute address (using lui) or a PC-relative one (using auipc for position-independent code). (Using a constant zero base address allows single-instruction calls to a small (the offset), fixed positive or negative address.)
RISC-V recycles jal and jalr to get unconditional 20-bit PC-relative jumps and unconditional register-based 12-bit jumps. Jumps just make the linkage register 0 so that no return address is saved.: Section 2.5 
RISC-V also recycles jalr to return from a subroutine: To do this, jalr's base register is set to be the linkage register saved by jal or jalr. jalr's offset is zero and the linkage register is zero, so that there is no offset, and no return address is saved.
Like many RISC designs, in a subroutine call, a RISC-V compiler must use individual instructions to save registers to the stack at the start, and then restore these from the stack on exit. RISC-V has no save multiple or restore multiple register instructions. These were thought to make the CPU too complex, and possibly slow. This can take more code space. Designers planned to reduce code size with library routines to save and restore registers.
RISC-V has no condition code register or carry bit. The designers believed that condition codes make fast CPUs more complex by forcing interactions between instructions in different stages of execution. This choice makes multiple-precision arithmetic more complex. Also, a few numerical tasks need more energy. As a result, predication (the conditional execution of instructions) is not supported. The designers claim that very fast, out-of-order CPU designs do predication anyway, by doing the comparison branch and conditional code in parallel, then discarding the unused path's effects. They also claim that even in simpler CPUs, predication is less valuable than branch prediction, which can prevent most stalls associated with conditional branches. Code without predication is larger, with more branches, but they also claim that a compressed instruction set (such as RISC-V's set C) solves that problem in most cases.
Instead, RISC-V has short branches that perform comparisons: equal, not-equal, less-than, unsigned less-than, greater-than or equal and unsigned greater-than or equal. Ten comparison-branch operations are implemented with only six instructions, by reversing the order of operands in the assembler. For example, branch if greater than can be done by less-than with a reversed order of operands.: Section 2.5 
The comparing branches have a twelve-bit signed range, and jump relative to the PC.: Section 2.5 
Unlike some RISC architectures, RISC-V does not include a branch delay slot, a position after a branch instruction that can be filled with an instruction that is executed whether or not the branch is taken.: Section 2.5  RISC-V omits a branch delay slot because it complicates multicycle CPUs, superscalar CPUs, and long pipelines. Dynamic branch predictors have succeeded well enough to reduce the need for delayed branches.
On the first encounter with a branch, RISC-V CPUs should assume that a negative relative branch (i.e. the sign bit of the offset is "1") will be taken.: Section 2.5  This assumes that a backward branch is a loop, and provides a default direction so that simple pipelined CPUs can fill their pipeline of instructions. Other than this, RISC-V does not require branch prediction, but core implementations are allowed to add it. RV32I reserves a "HINT" instruction space that presently does not contain any hints on branches;: Section 2.9  RV64I does the same.: Section 5.4 
Arithmetic and logic sets
RISC-V segregates math into a minimal set of integer instructions (set I) with add, subtract, shift, bitwise logic and comparing-branches. These can simulate most of the other RISC-V instruction sets with software. (The atomic instructions are a notable exception.) RISC-V integer instructions lacks the count leading zero and bit-field operations normally used to speed software floating-point in a pure-integer processor, However, while nominally in the bit manipulation extension, the ratified Zbb, Zba and Zbs extensions contain further integer instructions including a count leading zero instruction.
The integer multiplication instructions (set M) include signed and unsigned multiply and divide. Double-precision integer multiplies and divides are included, as multiplies and divides that produce the high word of the result. The ISA document recommends that implementors of CPUs and compilers fuse a standardized sequence of high and low multiply and divide instructions to one operation if possible.: 43–45 
The floating-point instructions (set F) include single-precision arithmetic and also comparison-branches similar to the integer arithmetic. It requires an additional set of 32 floating-point registers. These are separate from the integer registers. The double-precision floating point instructions (set D) generally assume that the floating-point registers are 64-bit (i.e., double-width), and the F subset is coordinated with the D set. A quad-precision 128-bit floating-point ISA (Q) is also defined.: 63–82  RISC-V computers without floating-point can use a floating-point software library.
RISC-V does not cause exceptions on arithmetic errors, including overflow,: 17–20  underflow, subnormal, and divide by zero.: 44–45  Instead, both integer and floating-point arithmetic produce reasonable default values, and floating-point instructions set status bits.: 66  Divide-by-zero can be discovered by one branch after the division.: 44–45  The status bits can be tested by an operating system or periodic interrupt.
Atomic memory operations
RISC-V supports computers that share memory between multiple CPUs and threads. RISC-V's standard memory consistency model is release consistency. That is, loads and stores may generally be reordered, but some loads may be designated as acquire operations which must precede later memory accesses, and some stores may be designated as release operations which must follow earlier memory accesses.: 83–94 
The base instruction set includes minimal support in the form of a fence instruction to enforce memory ordering.: 26–27  Although this is sufficient (fence r, rw provides acquire and fence rw, w provides release), combined operations can be more efficient.: Chapter 8 
The atomic memory operation extension supports two types of atomic memory operations for release consistency. First, it provides general purpose load-reserved lr and store-conditional sc instructions. lr performs a load, and tries to reserve that address for its thread. A later store-conditional sc to the reserved address will be performed only if the reservation is not broken by an intervening store from another source. If the store succeeds, a zero is placed in a register. If it failed, a non-zero value indicates that software needs to retry the operation. In either case, the reservation is released.: Chapter 8 
The second group of atomic instructions perform read-modify-write sequences: a load (which is optionally a load-acquire) to a destination register, then an operation between the loaded value and a source register, then a store of the result (which may optionally be a store-release). Making the memory barriers optional permits combining the operations. The optional operations are enabled by acquire and release bits which are present in every atomic instruction. RISC-V defines nine possible operations: swap (use source register value directly); add; bitwise and, or, and exclusive-or; and signed and unsigned minimum and maximum.: Chapter 8 
A system design may optimize these combined operations more than lr and sc. For example, if the destination register for a swap is the constant zero, the load may be skipped. If the value stored is unmodified since the load, the store may be skipped.: 44 
The IBM System/370 and its successors including z/Architecture, and x86, both implement a compare-and-swap (cas) instruction, which tests and conditionally updates a location in memory: if the location contains an expected old value, cas replaces it with a given new value; it then returns an indication of whether it made the change. However, a simple load-type instruction is usually performed before the cas to fetch the old value. The classic problem is that if a thread reads (loads) a value A, calculates a new value C, and then uses (cas) to replace A with C, it has no way to know whether concurrent activity in another thread has replaced A with some other value B and then restored the A in between. In some algorithms (e.g., ones in which the values in memory are pointers to dynamically allocated blocks), this ABA problem can lead to incorrect results. The most common solution employs a double-wide cas instruction to update both the pointer and an adjacent counter; unfortunately, such an instruction requires a special instruction format to specify multiple registers, performs several reads and writes, and can have complex bus operation.: 48–49 
The lr/sc alternative is more efficient. It usually requires only one memory load, and minimizing slow memory operations is desirable. It's also exact: it controls all accesses to the memory cell, rather than just assuring a bit pattern. However, unlike cas, it can permit livelock, in which two or more threads repeatedly cause each other's instructions to fail. RISC-V guarantees forward progress (no livelock) if the code follows rules on the timing and sequence of instructions: 1) It must use only the I subset. 2) To prevent repetitive cache misses, the code (including the retry loop) must occupy no more than 16 consecutive instructions. 3) It must include no system or fence instructions, or taken backward branches between the lr and sc. 4) The backward branch to the retry loop must be to the original sequence.: 48–49 
The specification gives an example of how to use the read-modify-write atomic instructions to lock a data structure.: 54 
Compressed subset
The standard RISC-V ISA specifies that all instructions are 32 bits. This makes for a particularly simple implementation, but like other RISC processors with 32-bit instruction encoding, results in larger code size than in instruction sets with variable-length instructions.: 99 
To compensate, RISC-V's 32-bit instructions are actually 30 bits; 3⁄4 of the opcode space is reserved for an optional (but recommended) variable-length compressed instruction set, RVC, that includes 16-bit instructions. Like ARM's Thumb and the MIPS16, the compressed instructions are simply aliases for a subset of the larger instructions. Unlike ARM's Thumb or the MIPS compressed set, space was reserved from the beginning so there is no separate operating mode. Standard and compressed instructions may be intermixed freely.: 97  (Extension letter is C.): 97 
Because (like Thumb-1 and MIPS16) the compressed instructions are simply alternate encodings (aliases) for a selected subset of larger instructions, the compression can be implemented in the assembler, and it is not essential for the compiler to even know about it.
A prototype of RVC was tested in 2011. The prototype code was 20% smaller than an x86 PC and MIPS compressed code, and 2% larger than ARM Thumb-2 code. It also substantially reduced both the needed cache memory and the estimated power use of the memory system.
The researcher intended to reduce the code's binary size for small computers, especially embedded computer systems. The prototype included 33 of the most frequently used instructions, recoded as compact 16-bit formats using operation codes previously reserved for the compressed set. The compression was done in the assembler, with no changes to the compiler. Compressed instructions omitted fields that are often zero, used small immediate values or accessed subsets (16 or 8) of the registers. addi is very common and often compressible.
Much of the difference in size compared to ARM's Thumb set occurred because RISC-V, and the prototype, have no instructions to save and restore multiple registers. Instead, the compiler generated conventional instructions that access the stack. The prototype RVC assembler then often converted these to compressed forms that were half the size. However, this still took more code space than the ARM instructions that save and restore multiple registers. The researcher proposed to modify the compiler to call library routines to save and restore registers. These routines would tend to remain in a code cache and thus run fast, though probably not as fast as a save-multiple instruction.
Standard RVC requires occasional use of 32-bit instructions. Several nonstandard RVC proposals are complete, requiring no 32-bit instructions, and are said to have higher densities than standard RVC. Another proposal builds on these, and claims to use less coding range as well.
Embedded subset
An instruction set for the smallest embedded CPUs (set E) is reduced in other ways: Only 16 of the 32 integer registers are supported.: Chapter 4  All current extensions may be used; a floating-point extension to use the integer registers for floating-point values is being considered. The privileged instruction set supports only machine mode, user mode and memory schemes that use base-and-bound address relocation.
Discussion has occurred for a microcontroller profile for RISC-V, to ease development of deeply embedded systems. It centers on faster, simple C-language support for interrupts, simplified security modes and a simplified POSIX application binary interface.
Correspondents have also proposed smaller, non-standard, 16-bit RV16E ISAs: Several serious proposals would use the 16-bit C instructions with 8 × 16-bit registers. An April fools' joke proposed a very practical arrangement: Utilize 16 × 16-bit integer registers, with the standard EIMC ISAs (including 32-bit instructions.) The joke was to use bank switching when a 32-bit CPU would be clearly superior with the larger address space.
Privileged instruction set
RISC-V's ISA includes a separate privileged instruction set specification. As of December 2021, version 1.12 is ratified by RISC-V International.
Version 1.11 of the specification supports several types of computer systems:
These correspond roughly to systems with up to four rings of privilege and security, at most: machine, hypervisor, supervisor and user. Each layer also is expected to have a thin layer of standardized supporting software that communicates to a more-privileged layer, or hardware.
The ISA also includes a hypervisor mode that is orthogonal to the user and supervisor modes. The basic feature is a configuration bit that either permits supervisor-level code to access hypervisor registers, or causes an interrupt on accesses. This bit lets supervisor mode directly handle the hardware needed by a hypervisor. This simplifies the implementation of hypervisors that are hosted by an operating system. This is a popular mode to run warehouse-scale computers. To support non-hosted hypervisors, the bit can cause these accesses to interrupt to a hypervisor. The design also simplifies nesting of hypervisors, in which a hypervisor runs under a hypervisor, and if necessary it lets the kernel use hypervisor features within its own kernel code. As a result, the hypervisor form of the ISA supports five modes: machine, supervisor, user, supervisor-under-hypervisor and user-under-hypervisor.
The privileged instruction set specification explicitly defines hardware threads, or harts. Multiple hardware threads are a common practice in more-capable computers. When one thread is stalled, waiting for memory, others can often proceed. Hardware threads can help make better use of the large number of registers and execution units in fast out-of-order CPUs. Finally, hardware threads can be a simple, powerful way to handle interrupts: No saving or restoring of registers is required, simply executing a different hardware thread. However, the only hardware thread required in a RISC-V computer is thread zero.
The existing control and status register definitions support RISC-V's error and memory exceptions, and a small number of interrupts. For systems with more interrupts, the specification also defines an interrupt controller. Interrupts always start at the highest-privileged machine level, and the control registers of each level have explicit forwarding bits to route interrupts to less-privileged code. For example, the hypervisor need not include software that executes on each interrupt to forward an interrupt to an operating system. Instead, on set-up, it can set bits to forward the interrupt.
Several memory systems are supported in the specification. Physical-only is suited to the simplest embedded systems. There are also three UNIX-style virtual memory systems for memory cached in mass-storage systems. The virtual memory systems support MMU with three sizes, with addresses sized 32, 39 and 48 bits. All virtual memory systems support 4 KiB pages, multilevel page-table trees and use very similar algorithms to walk the page table trees. All are designed for either hardware or software page-table walking. To optionally reduce the cost of page table walks, super-sized pages may be leaf pages in higher levels of a system's page table tree. SV32 has a two-layer page table tree and supports 4 MiB superpages. SV39 has a three level page table, and supports 2 MiB superpages and 1 GiB gigapages. SV48 is required to support SV39. It also has a 4-level page table and supports 2 MiB superpages, 1 GiB gigapages, and 512 GiB terapages. Superpages are aligned on the page boundaries for the next-lowest size of page.
Bit manipulation
Some Bit-Manipulation ISA-extensions were ratified in November 2021 (Zba, Zbb, Zbc, Zbs).. The Zba, Zbb, and Zbs extensions are arguably extensions of the standard I integer instructions: Zba contains instructions to speed up the computation of the addresses of array elements in arrays of datatypes of size 2, 4, or 8 bytes (sh1add, sh2add, sh3add), and for 64 (and 128) bit processors when indexed with unsigned integers (add.uw, sh1add.uw, sh2add.uw, sh3add.uw and slli.uw). The Zbb instructions contains operations to count leading, trailing 0 bits or all 1 bits in a full and 32 word operations (clz, clzw, ctz, ctzw, cpop, cpopw), byte order reversion (rev8), logical instructions with negation of the second input (andn,orn, xnor), sign and zero extension (sext.b, sext.h, zext.h) that could not be provided as special cases of other instructions (andi, addiw, add.wu), min and max of (signed and unsigned) integers, (left and right) rotation of bits in a register and 32 bit words (rori,roriw, ror, rorw, rol, rolw), and a byte wise "or combine" operation which allows detection of a zero byte in a full register, useful for handling C-style nul terminated strings functions. The Zbs extension allows setting, getting, clearing, and toggling individual bits in a register by their index (bseti, bset, bexti, bext, bclri, bclr, binvi,binv). 
The Zbc extension has instructions for "carryless multiplication", which does the multiplication of polynomials over the Galois field GF(2) (clmul, clmulh, clmulr). These are useful for cryptography and CRC checks of data integrity.
Done well, more specialised bit-manipulation subset can aid cryptographic, graphic, and mathematical operations. Further instructions that have been discussed include instructions to shift in ones, a generalized bit-reverse, shuffle and crossbar permutations, bit-field place, extract and deposit
pack two words, bytes or halfwords in one register, CRC instructions, bit-matrix operations (RV64 only), conditional mix, conditional move, funnel shifts. The criteria for inclusion documented in the draft were compliant with RV5 philosophies and ISA formats, substantial improvements in code density or speed (i.e., at least a 3-for-1 reduction in instructions), and substantial real-world applications, including preexisting compiler support. Version 0.93 includes.
Packed SIMD
Packed-SIMD instructions are widely used by commercial CPUs to inexpensively accelerate multimedia and other digital signal processing. For simple, cost-reduced RISC-V systems, the base ISA's specification proposed to use the floating-point registers' bits to perform parallel single instruction, multiple data (SIMD) sub-word arithmetic.
In 2017 a vendor published a more detailed proposal to the mailing list, and this can be cited as version 0.1. As of 2019, the efficiency of this proposed ISA varies from 2x to 5x a base CPU for a variety of DSP codecs. The proposal lacked instruction formats and a license assignment to RISC-V International, but it was reviewed by the mailing list. Some unpopular parts of this proposal were that it added a condition code, the first in a RISC-V design, linked adjacent registers (also a first), and has a loop counter that can be difficult to implement in some microarchitectures.
A previous, well-regarded implementation for a 64-bit CPU was PA-RISC's multimedia instructions: Multimedia Acceleration eXtensions. It increased the CPU's performance on digital signal processing tasks by 48-fold or more, enabling practical real-time video codecs in 1995. Besides its native 64-bit math, the PA-RISC MAX2 CPU could do arithmetic on four 16-bit subwords at once, with several overflow methods. It also could move subwords to different positions. PA-RISC's MAX2 was intentionally simplified. It lacked support for 8-bit or 32-bit subwords. The 16-bit subword size was chosen to support most digital signal processing tasks. These instructions were inexpensive to design and build.
Vector set
The proposed vector-processing instruction set may make the packed SIMD set obsolete. The designers hope to have enough flexibility that a CPU can implement vector instructions in a standard processor's registers. This would enable minimal implementations with similar performance to a multimedia ISA, as above. However, a true vector coprocessor could execute the same code with higher performance.
As of 19 September 2021, the vector extension is at version 1.0. It is a conservative, flexible design of a general-purpose mixed-precision vector processor, suitable to execute compute kernels. Code would port easily to CPUs with differing vector lengths, ideally without recompiling.
In contrast, short-vector SIMD extensions are less convenient. These are used in x86, ARM and PA-RISC. In these, a change in word-width forces a change to the instruction set to expand the vector registers (in the case of x86, from 64-bit MMX registers to 128-bit Streaming SIMD Extensions (SSE), to 256-bit Advanced Vector Extensions (AVX), and AVX-512). The result is a growing instruction set, and a need to port working code to the new instructions.
In the RISC-V vector ISA, rather than fix the vector length in the architecture, instructions (vsetvli, vsetivli, and vsetvl) are available which take a requested size and sets the vector length to the minimum of the hardware limit and the requested size. So, the RISC-V proposal is more like a Cray's long-vector design or ARM's Scalable Vector Extension. That is, each vector in up to 32 vectors is the same length.: 25 
The application specifies the total vector width it requires, and the processor determines the vector length it can provide with available on-chip resources. This takes the form of an instruction (vsetcfg) with four immediate operands, specifying the number of vector registers of each available width needed. The total must be no more than the addressable limit of 32, but may be less if the application does not require them all. The vector length is limited by the available on-chip storage divided by the number of bytes of storage needed for each entry. (Added hardware limits may also exist, which in turn may permit SIMD-style implementations.)
Outside of vector loops, the application can zero the number of requested vector registers, saving the operating system the work of preserving them on context switches.
The vector length is not only architecturally variable, but designed to vary at run time also. To achieve this flexibility, the instruction set is likely to use variable-width data paths and variable-type operations using polymorphic overloading. The plan is that these can reduce the size and complexity of the ISA and compiler.
Recent experimental vector processors with variable-width data paths also show profitable increases in operations per: second (speed), area (lower cost), and watt (longer battery life).
Unlike a typical modern graphics processing unit, there are no plans to provide special hardware to support branch predication. Instead, lower cost compiler-based predication will be used.
External debug system
There is a preliminary specification for RISC-V's hardware-assisted debugger. The debugger will use a transport system such as Joint Test Action Group (JTAG) or Universal Serial Bus (USB) to access debug registers. A standard hardware debug interface may support either a standardized abstract interface or instruction feeding.
As of January 2017, the exact form of the abstract interface remains undefined, but proposals include a memory mapped system with standardized addresses for the registers of debug devices or a command register and a data register accessible to the communication system. Correspondents claim that similar systems are used by Freescale's background debug mode interface (BDM) for some CPUs, ARM, OpenRISC, and Aeroflex's LEON.
In instruction feeding, the CPU will process a debug exception to execute individual instructions written to a register. This may be supplemented with a data-passing register and a module to directly access the memory. Instruction feeding lets the debugger access the computer exactly as software would. It also minimizes changes in the CPU, and adapts to many types of CPU. This was said to be especially apt for RISC-V because it is designed explicitly for many types of computers. The data-passing register allows a debugger to write a data-movement loop to RAM, and then execute the loop to move data into or out of the computer at a speed near the maximum speed of the debug system's data channel. Correspondents say that similar systems are used by MIPS Technologies MIPS, Intel Quark, Tensilica's Xtensa, and for Freescale Power ISA CPUs' background debug mode interface (BDM).
A vendor proposed a hardware trace subsystem for standardization, donated a conforming design, and initiated a review. The proposal is for a hardware module that can trace code execution on most RV5 CPUs. To reduce the data rate, and permit simpler or less-expensive paths for the trace data, the proposal does not generate trace data that can be calculated from a binary image of the code. It sends only data that indicates "uninferrable" paths through the program, such as which conditional branches are taken. To reduce the data rates, branches that can be calculated, such as unconditional branches, are not traced. The proposed interface between the module and the control unit is a logic signal for each uninferrable type of instruction. Addresses and other data are to be provided in a specialized bus attached to appropriate data sources in a CPU. The data structure sent to an external trace unit is a series of short messages with the needed data. The details of the data channel are intentionally not described in the proposal, because several are likely to make sense.
Implementations
The RISC-V organization maintains a list of RISC-V CPU and SoC implementations.
Existing
Existing proprietary implementations include:
In development
Open source
Many open-sourced RISC-V CPU designs exist, including:
Software
A normal problem for a new instruction set is a lack of CPU designs and software — both issues limit its usability and reduce adoption. RISC-V has a large number of CPU designs. RISC-V software includes toolchains, operating systems, middleware and design software.
Available RISC-V software tools include a GNU Compiler Collection (GCC) toolchain (with GDB, the debugger), an LLVM toolchain, the OVPsim simulator (and library of RISC-V Fast Processor Models), the Spike simulator, and a simulator in QEMU (RV32GC/RV64GC). JEP 422: Linux/RISC-V Port is already integrated into mainline OpenJDK repository.
Operating system support exists for the Linux kernel, FreeBSD, NetBSD, and OpenBSD but the supervisor-mode instructions were unstandardized before until version 1.11 of the privileged ISA specification, so this support is provisional. The preliminary FreeBSD port to the RISC-V architecture was upstreamed in February 2016, and shipped in FreeBSD 11.0. Ports of the Debian and Fedora Linux distributions, and a port of Haiku, are stabilizing (both only support 64-bit RISC-V, with no plans to support 32-bit version). A port of Das U-Boot exists. UEFI Spec v2.7 has defined the RISC-V binding and a TianoCore port has been done by HPE engineers and is expected to be upstreamed. There is a preliminary port of the seL4 microkernel. Hex Five released the first Secure IoT Stack for RISC-V with FreeRTOS support. Also xv6, a modern reimplementation of Sixth Edition Unix in ANSI C used for pedagogical purposes in MIT, was ported. Pharos RTOS has been ported to 64-bit RISC-V (including time and memory protection). Also see Comparison of real-time operating systems.
A simulator exists to run a RISC-V Linux system on a web browser using JavaScript.
QEMU supports running (using binary translation) 32- and 64-bit RISC-V systems (e.g. Linux) with a number of emulated or virtualized devices (serial, parallel, USB, network, storage, real time clock, watchdog, audio), as well as running RISC-V Linux binaries (translating syscalls to the host kernel). It does support multi-core emulation (SMP).
The Creator simulator is portable and allows the user to learn various assembly languages of different processors (Creator has examples with an implementation of RISC-V and MIPS32 instructions).
The extensible educational simulator WepSIM implements a (microprogrammed) subset of RISC-V instructions (RV32I+M) and allows the execution of subroutines in assembly.
A number of languages have been applied to creating RISC-V IP cores including a Scala-based hardware description language, Chisel, which can reduce the designs to Verilog for use in devices, and the CodAL processor description language which has been used in to describe RISC-V processor cores and to generate corresponding HDKs (RTL, testbench and UVM) and SDKs. The RISC-V International Compliance Task Group has a GitHub repository for RV32IMC.
Development tools
See also
References
Further reading