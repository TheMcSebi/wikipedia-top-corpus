Rust (programming language)
Rust is a multi-paradigm, general-purpose programming language. Rust emphasizes performance, type safety, and concurrency. Rust enforces memory safety—that is, that all references point to valid memory—without requiring the use of a garbage collector or reference counting present in other memory-safe languages. To simultaneously enforce memory safety and prevent concurrent data races, Rust's "borrow checker" tracks the object lifetime of all references in a program during compilation. Rust is popular for systems programming but also offers high-level features including some functional programming constructs.


Software developer Graydon Hoare created Rust as a personal project while working at Mozilla Research in 2006. Mozilla officially sponsored the project in 2009. Since the first stable release in May 2015, Rust has been adopted by companies including Amazon, Discord, Dropbox, Facebook (Meta), Google (Alphabet), and Microsoft.
Rust has been noted for its growth as a newer language and has been the subject of academic programming languages research.
History
Origins (2006–2012)
Rust grew out of a personal project begun in 2006 by Mozilla Research employee Graydon Hoare. Mozilla began sponsoring the project in 2009 as a part of the ongoing development of an experimental browser engine called Servo. The project was officially announced by Mozilla in 2010. During the same year, work had shifted from the initial compiler written in OCaml to a self-hosting compiler based on LLVM written in Rust. The new Rust compiler successfully compiled itself in 2011.
Evolution (2012–2019)
Rust's type system underwent significant changes between versions 0.2, 0.3, and 0.4. In version 0.2, which was released in March 2012, classes were introduced for the first time. Four months later, version 0.3 added destructors and polymorphism through the use of interfaces. In October 2012, version 0.4 was released and added traits as a means for inheritance. Interfaces were unified with traits and removed as a separate feature, and classes were replaced by a combination of implementations and structured types. Prior to version 0.4, Rust also supported typestate analysis through contracts. It was removed in release 0.4, though the same functionality can be achieved by leveraging Rust's type system.
In January 2014, the editor-in-chief of Dr. Dobb's Journal, Andrew Binstock, commented on Rust's chances of becoming a competitor to C++ in addition to the languages D, Go, and Nim (then Nimrod). According to Binstock, while Rust was "widely viewed as a remarkably elegant language", adoption slowed because it repeatedly changed between versions. The first stable release, Rust 1.0, was announced on May 15, 2015.
Mozilla layoffs and Rust Foundation (2020–present)
In August 2020, Mozilla laid off 250 of its 1,000 employees worldwide as part of a corporate restructuring caused by the COVID-19 pandemic. The team behind Servo, a browser engine written in Rust, was completely disbanded. The event raised concerns about the future of Rust, as some members of the team were active contributors to Rust. In the following week, the Rust Core Team acknowledged the severe impact of the layoffs and announced that plans for a Rust foundation were underway. The first goal of the foundation would be to take ownership of all trademarks and domain names, and take financial responsibility for their costs.
On February 8, 2021, the formation of the Rust Foundation was announced by its five founding companies (AWS, Huawei, Google, Microsoft, and Mozilla). In a blog post published on April 6, 2021, Google announced support for Rust within Android Open Source Project as an alternative to C/C++.
On November 22, 2021, the Moderation team, responsible for enforcing community standards and the Code of Conduct, announced their resignation "in protest of the Core Team placing themselves unaccountable to anyone but themselves." In May 2022, the Rust core team, other leads, and certain members of the Rust Foundation board sent out a statement with governance reforms in response to the incident.
Syntax and semantics
Hello World program
Below is a "Hello, World!" program in Rust.  The fn keyword is used to denote a function, and the println! macro prints the message to standard output. Statements in Rust are separated by semicolons.
Keywords and control flow
In Rust, blocks of code are delimited by curly brackets, and control flow is annotated with keywords such as if, else, while, and for. Pattern matching can be done using the match keyword. In the examples below, explanations are given in comments, which start with //.
Expression blocks
Despite its syntactic resemblance to C and C++, Rust is more significantly influenced by functional programming languages, including Standard ML, OCaml, Haskell, and Erlang. For example, nearly every part of a function body is an expression, even control flow operators. The ordinary if expression also takes the place of C's ternary conditional. A function does not need to end with a return expression: if the semicolon is omitted, the value of the last expression in the function will be used as the return value, as seen in the following recursive implementation of the factorial function:
The following iterative implementation uses the ..= operator to create an inclusive range:
Types
Rust is strongly typed and statically typed: all types of variables must be known during compilation, and assigning a value of a different type to a variable will result in a compilation error. The default integer type is i32, and the default floating point type is f64. If the type of a literal number is not explicitly provided, either it is inferred from the context or the default type is used.
Unlike other languages, Rust does not use null pointers to indicate a lack of data, as doing so can lead to accidental dereferencing. Therefore, in order to uphold its safety guarantees, it is impossible to dereference null pointers unless the code block is manually checked and explicitly declared unsafe through the use of an unsafe block. Rust instead uses an Option type, which has two variants, Some(T) (which indicates that a value is present) and None (analogous to the null pointer). Option implements a "null pointer optimization" avoiding any overhead for types which cannot have a null value (references or the NonZero types, for example). Option values must be handled using syntactic sugar, such as the if let construction, in order to access the inner value (in this case, a string):
Generics
More advanced features in Rust include the use of generic functions to reduce duplicate code. This capability is called parametric polymorphism. The following is a Rust program to calculate the sum of two things, for which addition is implemented using a generic function:
At compile-time, polymorphic functions like sum are instantiated with the specific types that are needed by the code (in this case, sum of integers and sum of floats).
Generics can be used in functions to allow implementing a behavior for different types without repeating the same code. Generic functions can be written in relation to other generics, without knowing the actual type.
Ownership and lifetimes
Rust's ownership system consists of rules that ensure memory safety without using a garbage collector. In the system, each value in Rust must be attached to a variable called the owner of that value, and every value must have exactly one owner. Values are moved between different owners through assignment or passing a value as a function parameter. Values can also be borrowed, meaning that they are temporarily passed to a different function before being returned to the owner.  With these rules, Rust can prevent the creation and use of dangling pointers:
Lifetimes are a usually implicit part of all reference types in Rust. Each particular lifetime encompasses a set of locations in the code for which a variable is valid. The borrow checker in the Rust compiler uses lifetimes to ensure that the values pointed to by a reference remain valid. It also ensures that a mutable reference only exists if no immutable references exist at the same time. Rust's memory and ownership system was influenced by region-based memory management in languages such as Cyclone and ML Kit.
Rust defines the relationship between the lifetimes of the objects used and created by functions as part of their signature using lifetime parameters.
When a stack variable or temporary goes out of scope, it is dropped by running its destructor. The destructor may be programmatically defined through the drop function. This structure enforces the so-called resource acquisition is initialization (RAII) design pattern, in which resources, like file descriptors or network sockets, are tied to the lifetime of an object: when the object is dropped, the resource is closed.
The example below parses some configuration options from a string and creates a struct containing the options. The struct only contains references to the data, so for the struct to remain valid, the data referred to by the struct needs to be valid as well. The function signature for parse_config specifies this relationship explicitly. In this example, the explicit lifetimes are unnecessary in newer Rust versions due to lifetime elision, which is an algorithm that automatically assigns lifetimes to functions if they are trivial.
Features
Rust aims to support concurrent systems programming, which has inspired a feature set with an emphasis on safety, control of memory layout, and concurrency.
Memory safety
Rust is designed to be memory safe. It does not permit null pointers, dangling pointers, or data races. Data values can be initialized only through a fixed set of forms, all of which require their inputs to be already initialized.  To replicate pointers being either valid or NULL, such as in linked list or binary tree data structures, the Rust core library provides an option type, which can be used to test whether a pointer has Some value or None.  Rust has added syntax to manage lifetimes, which are checked at compile time by the borrow checker. Unsafe code can subvert some of these restrictions using the unsafe keyword. Unsafe code may also be used for low-level functionality like volatile memory access, architecture-specific intrinsics, type punning, and inline assembly.: 139, 376–379, 395 
Memory management
Rust does not use automated garbage collection. Memory and other resources are managed through the "resource acquisition is initialization" convention, with optional reference counting. Rust provides deterministic management of resources, with very low overhead. Values are allocated on the stack by default and all dynamic allocations must be explicit.
The built-in reference types using the & symbol do not involve run-time reference counting. The safety and validity of the underlying pointers is verified at compile time, preventing dangling pointers and other forms of undefined behavior. Rust's type system separates shared, immutable references of the form &T from unique, mutable references of the form &mut T. A mutable reference can be coerced to an immutable reference, but not vice versa.
Types and polymorphism
Rust's type system supports a mechanism called traits, inspired by type classes in the Haskell language, to define shared behavior between different types. For example, floats and integers both implement the Add trait because they can both be added; and any type that can be converted to a string implements the Display or Debug traits. This facility is known as ad hoc polymorphism.
Rust uses type inference for variables declared with the keyword let. Such variables do not require a value to be initially assigned to determine their type. A compile time error results if any branch of code leaves the variable without an assignment. Variables assigned multiple times must be marked with the keyword mut (short for mutable).
A function can be given generic parameters, which allows the same function to be applied to different types. Generic functions can constrain the generic type to implement a particular trait or traits; for example, an add_one function might require the type to implement Add. This means that a generic function can be type-checked as soon as it is defined. The implementation of Rust generics is similar to the typical implementation of C++ templates: a separate copy of the code is generated for each instantiation. This is called monomorphization and contrasts with the type erasure scheme typically used in Java and Haskell. Type erasure is also available in Rust via the keyword dyn (short for dynamic). Because monomorphization duplicates the code for each type used, it can result in more optimized code for specific use cases, but compile time and size of the output binary are also increased.
In Rust, user-defined types are created with the struct or enum keywords. The struct keyword is used to denote a record type that groups multiple related values. enums can take on different variants in runtime, with its capabilities similiar to algebraic data types found in functional programming languages. Both structs and enums can contain fields with different types. The impl keyword can define methods for the types (data and functions are defined separately) or implement a trait for the types. Traits are used to restrict generic parameters and because traits can provide a type with more methods than the user defined. For example, the trait Iterator requires that the next method be defined for the type. Once the next method is defined the trait provides common functional helper methods over the iterator like map or filter.
Type aliases, including generic arguments, can also be defined with the type keyword.
The type system within Rust is based around implementations, traits and structured types. Implementations fulfill a role similar to that of classes within other languages and are defined with the keyword impl. Traits provide inheritance and polymorphism; they allow methods to be defined and mixed in to implementations. Structured types are used to define fields. Implementations and traits cannot define fields themselves, and only traits can provide inheritance. Among other benefits, this prevents the diamond problem of multiple inheritance, as in C++. In other words, Rust supports interface inheritance but replaces implementation inheritance with composition; see composition over inheritance.
Rust uses linear types, where each value is used exactly once, to enforce type safety. This enables software fault isolation with a low overhead.
Trait objects
Rust traits are implemented using static dispatch, meaning that the type of all values is known at compile time; however, Rust also uses a feature known as trait objects to accomplish dynamic dispatch (also known as duck typing). Dynamically dispatched trait objects are declared using the syntax Box<dyn Tr> where Tr is a trait. For example, it is possible to create a list of objects which each can be printed out as follows: let v: Vec<Box<dyn Display>> = vec![Box::new(3), Box::new(5.0), Box::new("hi")]. Trait objects are dynamically sized; however, prior to the 2018 edition, the dyn keyword was optional. A trait object is essentially a fat pointer that include a pointer as well as additional information about what type the pointer is.
Macros
It is possible to extend the Rust language using macros.
Declarative macros
A declarative macro (also called a "macro by example") is a macro that uses pattern matching to determine its expansion.
Procedural macros
Procedural macros use Rust functions that are compiled before other components to run and modify the compiler's input token stream. They are generally more flexible than declarative macros, but are more difficult to maintain due to their complexity.
Procedural macros come in three flavors:
The println! macro is an example of a function-like macro and serde_derive is a commonly used library for generating code
for reading and writing data in many formats such as JSON. Attribute macros are commonly used for language bindings such as the extendr library for Rust bindings to R.
The following code shows the use of the Serialize, Deserialize and Debug derive procedural macros
to implement JSON reading and writing as well as the ability to format a structure for debugging.
Interface with C and C++
Rust has a foreign function interface (FFI) that can be used both to call code written in languages such as C from Rust and to call Rust code from those languages. Rust also has a library, CXX, for calling to or from C++. Rust and C differ in how they lay out structs in memory, so Rust structs may be given a #[repr(C)] attribute, forcing the same layout as the equivalent C struct.
Components
Besides the compiler and standard library, the Rust ecosystem includes additional components for software development. Component installation is typically managed by rustup, a Rust toolchain installer developed by the Rust project.
Standard library
The Rust standard library is split into three crates: core, alloc, and std. When a project is annotated with the crate-level attribute #![no_std], the std crate is excluded.
Cargo
Cargo is Rust's build system and package manager. Cargo downloads, compiles, distributes, and uploads packages, called crates, maintained in the official registry. Cargo also acts as a front-end for Clippy and other Rust components.
By default, Cargo sources its dependencies from the user-contributed registry crates.io, but Git repositories and crates in the local filesystem and other external sources can be specified as dependencies, too.
Rustfmt
Rustfmt is a code formatter for Rust. It takes Rust source code as input and changes the whitespace and indentation to produce code formatted in accordance to a common style unless specified otherwise. Rustfmt can be invoked as a standalone program or on a Rust project through Cargo.
Clippy
Clippy is Rust's built-in linting tool to improve the correctness, performance, and readability of Rust code. It was created in 2014 and named after the eponymous Microsoft Office feature. As of 2021, Clippy has more than 450 rules, which can be browsed online and filtered by category.
Versioning system
Following Rust 1.0, new features are developed in nightly versions which release on a daily basis. During each release cycle of six weeks, changes on nightly versions are released to beta, while changes from the previous beta version are released to a new stable version.
Every two or three years, a new "edition" is produced. Editions are released to allow making limited breaking changes such as promoting await to a keyword to support async/await features. Editions are largely compatible and migration to a new edition can be assisted with automated tooling.
IDE support
The most popular language server for Rust is rust-analyzer. The original language server, RLS was officially deprecated in favor of rust-analyzer in July 2022. These projects provide IDEs and text editors with more information about a Rust project, with basic features including autocompletion, and display of compilation errors while editing.
Performance
Rust aims "to be as efficient and portable as idiomatic C++, without sacrificing safety". Rust does not perform garbage collection, which allows it to be more efficient and performant than other memory-safe languages.
Rust provides two "modes": safe and unsafe. The safe mode is the "normal" one, in which most Rust is written. In unsafe mode, the developer is responsible for the correctness of the code, making it possible to create applications which require low-level features. It has been demonstrated empirically that unsafe Rust is not always more performant than safe Rust, and can even be slower in some cases.
Many of Rust's features are so-called zero-cost abstractions, meaning they are optimized away at compile time and incur no runtime penalty.: 19,27  The ownership and borrowing system permits zero-copy implementations for some performance-sensitive tasks, such as parsing. Static dispatch is used by default to eliminate method calls, with the exception of methods called on dynamic trait objects.: 20  The compiler also uses inline expansion to eliminate function calls and statically dispatched method invocations entirely.
Since Rust utilizes LLVM, any performance improvements in LLVM also carry over to Rust. Unlike C and C++, Rust allows re-organizing struct and enum element ordering. This can be done to reduce the size of structures in memory, for better memory alignment, and to improve cache access efficiency.
Adoption
According to the Stack Overflow Developer Survey in 2022, 9% of respondents have recently done extensive development in Rust. The survey has additionally named Rust the "most loved programming language" every year from 2016 to 2022 (inclusive), a ranking based on the number of current developers who express an interest in continuing to work in the same language. In 2022, Rust tied with Python for "most wanted technology" with 18% of developers not currently working in Rust expressing an interest in doing so.
Rust has been adopted for components at a number of major software companies, including Amazon, Discord, Dropbox, Facebook (Meta), Google (Alphabet), and Microsoft.
Web browsers and services
Operating systems
Other notable projects and platforms
Community
Conferences
Rust's official website lists online forums, messaging platforms, and in-person meetups for the Rust community. Conferences dedicated to Rust development include:
Rust Foundation
The Rust Foundation is a non-profit membership organization incorporated in United States, with the primary purposes of backing the technical project as a legal entity and helping to manage the trademark and infrastructure assets.
It was established on February 8, 2021, with five founding corporate members (Amazon Web Services, Huawei, Google, Microsoft, and Mozilla). The foundation's board is chaired by Shane Miller. Starting in late 2021, its Executive Director and CEO is Rebecca Rumbul. Prior to this, Ashley Williams was interim executive director.
Governance teams
The Rust project is composed of teams that are responsible for different subareas of the development. For example, the Core team is responsible for "managing the overall direction of Rust, subteam leadership, and any cross-cutting issues," the Compiler team is responsible for "developing and managing compiler internals and optimizations," and the Language team is responsible for "designing and helping to implement new language features," according to the official website.
See also
Notes
References
Book sources
Others
Further reading