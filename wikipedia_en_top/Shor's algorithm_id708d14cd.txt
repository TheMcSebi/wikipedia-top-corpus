Shor's algorithm
Shor's algorithm is a quantum computer algorithm for finding the prime factors of an integer. It was developed in 1994 by the American mathematician Peter Shor.
On a quantum computer, to factor an integer $MATH$, Shor's algorithm runs in polynomial time, meaning the time taken is polynomial in $MATH$, the size of the integer given as input. Specifically, it takes quantum gates of order $MATH$ using fast multiplication, or even $MATH$ utilizing the asymptotically fastest multiplication algorithm currently known due to Harvey and Van Der Hoven, thus demonstrating that the integer factorization problem can be efficiently solved on a quantum computer and is consequently in the complexity class BQP. This is almost exponentially faster than the most efficient known classical factoring algorithm, the general number field sieve, which works in sub-exponential time: $MATH$. The efficiency of Shor's algorithm is due to the efficiency of the quantum Fourier transform, and modular exponentiation by repeated squarings.
If a quantum computer with a sufficient number of qubits could operate without succumbing to quantum noise and other quantum-decoherence phenomena, then Shor's algorithm could be used to break public-key cryptography schemes, such as
RSA is based on the assumption that factoring large integers is computationally intractable. As far as is known, this assumption is valid for classical (non-quantum) computers; no classical algorithm is known that can factor integers in polynomial time. However, Shor's algorithm shows that factoring integers is efficient on an ideal quantum computer, so it may be feasible to defeat RSA by constructing a large quantum computer. It was also a powerful motivator for the design and construction of quantum computers, and for the study of new quantum-computer algorithms. It has also facilitated research on new cryptosystems that are secure from quantum computers, collectively called post-quantum cryptography.
In 2001, Shor's algorithm was demonstrated by a group at IBM, who factored $MATH$ into $MATH$, using an NMR implementation of a quantum computer with $MATH$ qubits. After IBM's implementation, two independent groups implemented Shor's algorithm using photonic qubits, emphasizing that multi-qubit entanglement was observed when running the Shor's algorithm circuits. In 2012, the factorization of $MATH$ was performed with solid-state qubits. Later, in 2012, the factorization of $MATH$ was achieved. In 2019 an attempt was made to factor the number $MATH$ using Shor's algorithm on an IBM Q System One, but the algorithm failed because of accumulating errors.  Though larger numbers have been factored by quantum computers using other algorithms, these algorithms are similar to classical brute-force checking of factors, so unlike Shor's algorithm, they are not expected to ever perform better than classical factoring algorithms.
Procedure
The problem that we are trying to solve is, given a composite number $MATH$, to find a non-trivial divisor of $MATH$ (a divisor strictly between $MATH$ and $MATH$). Before attempting to find such a divisor, if there's any doubt whether $MATH$ is composite or prime, one can use relatively quick primality-testing algorithms to verify that $MATH$ is indeed composite, although this is not a part of Shor's algorithm.
Shor's algorithm consists of two parts:
The aim of the algorithm is to find a non-trivial square root $MATH$ of $MATH$ modulo $MATH$ that is different from $MATH$ and $MATH$, because then 
for a non-zero integer $MATH$ that gives us two distinct non-trivial divisors $MATH$ and $MATH$ of $MATH$.
This idea is similar to other factoring algorithms, such as the quadratic sieve, and a more detailed explanation can be found in the Explanation section below. Before starting the algorithm, it is imperative to check $MATH$ to be odd (otherwise $MATH$ is a divisor) and not to be any power of an integer (otherwise that integer is a divisor), so as to guarantee the existence of a non-trivial square root $MATH$ of $MATH$ modulo $MATH$.
In turn, finding such a $MATH$ is reduced to finding an element $MATH$ as a parameter in an integer function, such that the function has an even period with a certain additional property (as explained below, it is required that the condition of Step 6 of the classical part does not hold). The quantum algorithm is used for finding the period of randomly chosen elements $MATH$, as this is a difficult problem on a classical computer.
Classical part
For example: Given $MATH$, $MATH$, and $MATH$, i.e.,$MATH$ we have $MATH$, where $MATH$ and $MATH$. For $MATH$ that is a product of two distinct primes, $MATH$ and $MATH$,  $MATH$, which for $MATH$ is $MATH$, and $MATH$ divides $MATH$.
Quantum part: period-finding subroutine
The quantum circuits used for this algorithm are custom designed for each choice of $MATH$ and each choice of the random $MATH$ which have the relationship $MATH$. Given value $MATH$, a value $MATH$ is chosen such that $MATH$. Such a value of $MATH$ implies that $MATH$. The input and output qubit registers will store superpositions of values from $MATH$ to $MATH$. Therefore, these registers have $MATH$ qubits each. Using what might appear to be twice as many qubits as necessary guarantees that there are at least $MATH$ different values of $MATH$ that produce the same $MATH$, even as the period $MATH$ approaches $MATH$. The following uses bra-ket notation to denote quantum states.
Proceed as follows:
Explanation of the algorithm
The algorithm is composed of two parts. The first part of the algorithm turns the factoring problem into the problem of finding the period of a function and may be implemented classically. The second part finds the period using the quantum Fourier transform and is responsible for the quantum speedup.
Non-trivial square root of [1 modulo N]
Shor's algorithm hinges on finding a non-trivial square root of $MATH$ modulo $MATH$; That is, a solution to 
where $MATH$.
If such $MATH$ exists, we claim that $MATH$ is a proper factor of $MATH$, i.e., $MATH$. In fact, if
$MATH$, then $MATH$ divides $MATH$, so that $MATH$, which goes against the construction of $MATH$. If, on the other hand, $MATH$, then by Bézout's identity, there are integers $MATH$ such that
Multiplying both sides by $MATH$, we obtain
As $MATH$ divides $MATH$, we find that $MATH$ divides $MATH$, so that $MATH$, again contradicting the construction of $MATH$.
Therefore, $MATH$ is the required proper factor of $MATH$. Similarly, it can be proven that $MATH$ is also a proper factor of $MATH$.
For such a non-trivial square root of $MATH$ modulo $MATH$ to exist, notice that $MATH$, and for any power of an odd prime $MATH$, there is no non-trivial square root of $MATH$ modulo $MATH$: For any $MATH$ either $MATH$ or $MATH$ has to be a multiple of $MATH$.
Therefore, for Shor's algorithm to work, we need $MATH$ to be odd (otherwise $MATH$ is a divisor) and not to be any power of an odd prime (otherwise that prime is a divisor). We can check that there are no integer roots $MATH$ for $MATH$, and if $MATH$ is not a power of any integer, it is not a power of any odd prime. Here, the upper bound for the integer $MATH$ that we need to check is determined by $MATH$, since for $MATH$ to be odd, $MATH$ cannot be $MATH$. This check, however, cannot rule out that $MATH$ may be an odd prime itself, which can only be ruled out by primality-testing algorithms.
Given that $MATH$ is odd and not any power of an odd prime, based on the fundamental theorem of arithmetic, we may assume that $MATH$ is the product of two coprime integers greater than $MATH$ ($MATH$ and $MATH$). From the four combinations of choosing plus sign and minus sign in the integer equations $MATH$, based on the Chinese remainder theorem and $MATH$, there are at least four distinct square roots of $MATH$ modulo $MATH$, and therefore at least two distinct non-trivial square roots exist. In fact, they are the solutions to $MATH$ and $MATH$.
Obtaining factors from period
The integers less than $MATH$ and coprime with $MATH$ form the multiplicative group of integers modulo $MATH$, which is a finite abelian group $MATH$. The size of this group is given by $MATH$. By the end of step 3, we have an integer $MATH$ in this group. As the group is finite, $MATH$ must have a finite order $MATH$, which is the smallest positive integer such that
This is the order $MATH$ of the finite cyclic subgroup  ⟨a⟩ of the group $MATH$, which is the smallest positive integer $MATH$ for which $MATH$. Since $MATH$ and $MATH$ are coprime, by Euler's totient theorem, $MATH$ must exist, and divides $MATH$, where $MATH$ denotes Euler's totient function.
Therefore, $MATH$ divides $MATH$ (also written $MATH$). Suppose that we are able to obtain $MATH$ and that it is even. (If $MATH$ is odd, then by step 5, we have to restart the algorithm with a different random number $MATH$) Now $MATH$ is a square root of $MATH$ modulo $MATH$ that is different from $MATH$. This is because $MATH$ is the order of $MATH$ modulo $MATH$, so $MATH$, or else the order of $MATH$ in this group would be $MATH$. If $MATH$, then by step 6, we have to restart the algorithm with a different random number $MATH$.
Eventually, we must hit an $MATH$ of order $MATH$ in $MATH$ such that $MATH$. This is because such a $MATH$ is a square root of $MATH$ modulo $MATH$ other than $MATH$ and $MATH$, whose existence is guaranteed by the Chinese remainder theorem, as the odd number $MATH$ is not a prime power.
Finding the period
Shor's period-finding algorithm relies heavily on the ability of a quantum computer to be in many states simultaneously.
Physicists call this behavior a "superposition" of states. To compute the period of a function $MATH$, we evaluate the function at all points simultaneously.
Quantum physics does not allow us to access all this information directly, however. A measurement will yield only one of all possible values, destroying all others. If not for the no-cloning theorem, we could first measure $MATH$ without measuring $MATH$, and then make a few copies of the resulting state (which is a superposition of states all having the same $MATH$). Measuring $MATH$ on these states would provide different $MATH$ values which give the same $MATH$, leading to the period. Because we cannot make exact copies of a quantum state, this method does not work. Therefore, we have to carefully transform the superposition to another state that will return the correct answer with high probability. This is achieved by the quantum Fourier transform.
Shor thus had to solve three "implementation" problems. All of them had to be implemented "fast", which means that they can be implemented with a number of quantum gates that is polynomial in $MATH$.
After all these transformations, a measurement will yield an approximation to the period $MATH$. For simplicity assume that there is a $MATH$ such that $MATH$ is an integer. Then the probability to measure $MATH$ is $MATH$. To see this, we notice that then
for all integers $MATH$. Therefore, the sum whose square gives us the probability to measure $MATH$ will be $MATH$, as $MATH$ takes roughly $MATH$ values and thus the probability is $MATH$. There are $MATH$ possible values of $MATH$ such that $MATH$ is an integer, and also $MATH$ possibilities for $MATH$, so the probabilities sum to $MATH$.
The period-finding routine can be considered a variation of the more general quantum phase estimation algorithm to determine the eigenvalue of a unitary corresponding to an eigenvector. In the case of the period-finding routine used in Shor's Algorithm, the unitary in question is modular multiplication by the chosen base mod $MATH$. While the computational basis $MATH$ is not an eigenvector of this unitary, it is a uniform superposition of its $MATH$ eigenvectors and thus the measurement will give the eigenvalue's phase for one of the eigenvectors. Since not all such phases can be used to extract the period, the retries of the subroutine may be necessary.
The bottleneck
The runtime bottleneck of Shor's algorithm is quantum modular exponentiation, which is by far slower than the quantum Fourier transform and classical pre-/post-processing. There are several approaches to constructing and optimizing circuits for modular exponentiation. The simplest and (currently) most practical approach is to mimic conventional arithmetic circuits with reversible gates, starting with ripple-carry adders. Knowing the base and the modulus of exponentiation facilitates further optimizations. Reversible circuits typically use on the order of $MATH$ gates for $MATH$ qubits. Alternative techniques asymptotically improve gate counts by using quantum Fourier transforms, but are not competitive with fewer than 600 qubits owing to high constants.
Discrete logarithms
Given a group $MATH$ with order $MATH$ and generator $MATH$, suppose we know that $MATH$, for some $MATH$, and we wish to compute $MATH$, which is the discrete logarithm: $MATH$. Consider the abelian group $MATH$, where each factor corresponds to modular addition of values. Now, consider the function
This gives us an abelian hidden subgroup problem, as $MATH$ corresponds to a group homomorphism. The kernel corresponds to the multiples of $MATH$. So, if we can find the kernel, we can find $MATH$. A quantum algorithm for solving this problem exists. This algorithm is, like the factor-finding algorithm, due to Peter Shor and both are implemented by creating a superposition through using Hadamard gates, followed by implementing $MATH$ as a quantum transform, followed finally by a quantum Fourier transform. Due to this, the quantum algorithm for computing the discrete logarithm is also occasionally referred to as "Shor's Algorithm."
The order-finding problem can also be viewed as a hidden subgroup problem. To see this, consider the group of integers under addition, and for a given $MATH$ such that: $MATH$, the function
For any finite abelian group G, a quantum algorithm exists for solving the hidden subgroup for G in polynomial time.
See also
References
Further reading