Wayland (protocol)
Wayland is a communication protocol that specifies the communication between a display server and its clients, as well as a C library implementation of that protocol. A display server using the Wayland protocol is called a Wayland compositor, because it additionally performs the task of a compositing window manager.
Wayland is developed by a group of volunteers initially led by Kristian Høgsberg as a free and open-source community-driven project with the aim of replacing the X Window System with a modern, secure simpler windowing system in Linux and other Unix-like operating systems. The project's source code is published under the terms of the MIT License, a permissive free software licence.
As part of its efforts, the Wayland project also develops a reference implementation of a Wayland compositor called Weston.
Overview
The Wayland Display Server project was started by Red Hat developer Kristian Høgsberg in 2008.
Beginning around 2010, Linux desktop graphics have moved from having "a pile of rendering interfaces... all talking to the X server, which is at the center of the universe" towards putting the Linux kernel and its components (i.e. Direct Rendering Infrastructure (DRI), Direct Rendering Manager (DRM)) "in the middle", with "window systems like X and Wayland ... off in the corner". This will be "a much-simplified graphics system offering more flexibility and better performance".
Høgsberg could have added an extension to X as many recent projects have done, but preferred to "[push] X out of the hotpath between clients and the hardware" for reasons explained in the project's FAQ:
Wayland consists of a protocol and a reference implementation named Weston. The project is also developing versions of GTK and Qt that render to Wayland instead of to X. Most applications are expected to gain support for Wayland through one of these libraries without modification to the application.
Initial versions of Wayland have not provided network transparency, though Høgsberg noted in 2010 that network transparency is possible.
It was attempted as a Google Summer of Code project in 2011, but was not successful.
Adam Jackson has envisioned providing remote access to a Wayland application by either "pixel-scraping" (like VNC) or getting it to send a "rendering command stream" across the network (as in RDP, SPICE or X11). As of early 2013, Høgsberg was experimenting with network transparency using a proxy Wayland server which sends compressed images to the real compositor. In August 2017, GNOME saw the first such pixel-scraping VNC server implementation under Wayland.
Software architecture
Protocol architecture
The Wayland protocol follows a client–server model in which clients are the graphical applications requesting the display of pixel buffers on the screen, and the server (compositor) is the service provider controlling the display of these buffers.
The Wayland reference implementation has been designed as a two-layer protocol:
While the low-level layer was written manually in C, the high-level layer is automatically generated from a description of the elements of the protocol stored in XML format. Every time the protocol description of this XML file changes, the C source code that implements such protocol can be regenerated to include the new changes, allowing a very flexible, extensible and error-proof protocol.
The reference implementation of Wayland protocol is split in two libraries: a library to be used by Wayland clients called libwayland-client and a library to be used by Wayland compositors called libwayland-server.: 57 
Protocol overview
The Wayland protocol is described as an "asynchronous object-oriented protocol".: 9  Object-oriented means that the services offered by the compositor are presented as a series of objects living on the same compositor. Each object implements an interface which has a name, a number of methods (called requests) as well as several associated events. Every request and event has zero or more arguments, each one with a name and a data type. The protocol is asynchronous in the sense that requests do not have to wait for synchronized replies or ACKs, avoiding round-trip delay time and achieving improved performance.
The Wayland clients can make a request (a method invocation) on some object if the object's interface supports that request. The client must also supply the required data for the arguments of such request. This is the way the clients request services from the compositor. The compositor in turn sends information back to the client by causing the object to emit events (probably with arguments too). These events can be emitted by the compositor as a response to a certain request, or asynchronously, subject to the occurrence of internal events (such as one from an input device) or state changes. The error conditions are also signaled as events by the compositor.: 9 
For a client to be able to make a request to an object, it first needs to tell the server the ID number it will use to identify that object.: 9  There are two types of objects in the compositor: global objects and non-global objects. Global objects are advertised by the compositor to the clients when they are created (and also when they are destroyed), while non-global objects are usually created by other objects that already exist as part of their functionality.
The interfaces and their requests and events are the core elements that define the Wayland protocol. Each version of the protocol includes a set of interfaces, along with their requests and events, which are expected to be in any Wayland compositor. Optionally, a Wayland compositor may define and implement its own interfaces that support new requests and events, thereby extending functionality beyond the core protocol.: 10  To facilitate changes to the protocol, each interface contains a "version number" attribute in addition to its name; this attribute allows for distinguishing variants of the same interface. Each Wayland compositor exposes not only what interfaces are available, but also the supported versions of those interfaces.: 12 
Wayland core interfaces
The interfaces of the current version of Wayland protocol are defined in the file protocol/wayland.xml of the Wayland source code. This is an XML file that lists the existing interfaces in the current version, along with their requests, events and other attributes. This set of interfaces is the minimum required to be implemented by any Wayland compositor.
Some of the most basic interfaces of the Wayland protocol are:: 10–12 
A typical Wayland client session starts by opening a connection to the compositor using the wl_display object. This is a special local object that represents the connection and does not live within the server. By using its interface the client can request the wl_registry global object from the compositor, where all the global object names live, and bind those that the client is interested in. Usually the client binds at least a wl_compositor object from where it will request one or more wl_surface objects to show the application output on the display.
Wayland extension interfaces
A Wayland compositor can define and export its own additional interfaces.: 10  This feature is used to extend the protocol beyond the basic functionality provided by the core interfaces, and has become the standard way to implement Wayland protocol extensions. Certain compositors can choose to add custom interfaces to provide specialized or unique features. The Wayland reference compositor, Weston, used them to implement new experimental interfaces as a testbed for new concepts and ideas, some of which later became part of the core protocol (such as wl_subsurface interface added in Wayland 1.4).
XDG-Shell protocol
XDG-Shell protocol (see freedesktop.org for XDG) is an extended way to manage surfaces under Wayland compositors (not only Weston). The traditional way to manipulate (maximize, minimize, fullscreen, etc.) surfaces is to use the wl_shell_*() functions, which are part of the core Wayland protocol and live in libwayland-client. An implementation of the xdg-shell protocol, on the contrary, is supposed to be provided by the Wayland compositor. So you will find the xdg-shell-client-protocol.h header in the Weston source tree. Each Wayland compositor is supposed to provide its own implementation.
As of June 2014, XDG-Shell protocol was not versioned and still prone to changes.
xdg_shell is a protocol aimed to substitute wl_shell in the long term, but will not be part of the Wayland core protocol. It starts as a non-stable API, aimed to be used as a development place at first, and once features are defined as required by several desktop shells, it can be finally made stable. It provides mainly two new interfaces: xdg_surface and xdg_popup. The xdg_surface interface implements a desktop-style window that can be moved, resized, maximized, etc.; it provides a request for creating child/parent relationship. The xdg_popup interface implements a desktop-style popup/menu; an xdg_popup is always transient for another surface, and also has implicit grab.
IVI-Shell protocol
IVI-Shell is an extension to the Wayland core protocol, targeting in-vehicle infotainment (IVI) devices.
Rendering model
The Wayland protocol does not include a rendering API.: 7 : 2  Instead, Wayland follows a direct rendering model, in which the client must render the window contents to a buffer shareable with the compositor.: 7  For that purpose, the client can choose to do all the rendering by itself, use a rendering library like Cairo or OpenGL, or rely on the rendering engine of high-level widget libraries with Wayland support, such as Qt or GTK. The client can also optionally use other specialized libraries to perform specific tasks, such as Freetype for font rendering.
The resulting buffer with the rendered window contents are stored in a wl_buffer object. The internal type of this object is implementation dependent. The only requirement is that the content data must be shareable between the client and the compositor. If the client uses a software (CPU) renderer and the result is stored in the system memory, then client and compositor can use shared memory to implement the buffer communication without extra copies. The Wayland protocol already natively provides this kind of shared memory buffer through the wl_shm and wl_shm_pool interfaces.: 11, 20-21  The drawback of this method is that the compositor may need to do additional work (usually to copy the shared data to the GPU) to display it, which leads to slower graphics performance.
The most typical case is for the client to render directly into a video memory buffer using a hardware (GPU) accelerated API such as OpenGL, OpenGL ES or Vulkan. Client and compositor can share this GPU-space buffer using a special handler to reference it. This method allows the compositor to avoid the extra data copy through itself of the main memory buffer client-to-compositor-to-GPU method, resulting in faster graphics performance, and is therefore the preferred one. The compositor can further optimize the composition of the final scene to be shown on the display by using the same hardware acceleration API as an API client.
When rendering is completed in a shared buffer, the Wayland client should instruct the compositor to present the rendered contents of the buffer on the display. For this purpose, the client binds the buffer object that stores the rendered contents to the surface object, and sends a "commit" request to the surface, transferring the effective control of the buffer to the compositor. Then the client waits for the compositor to release the buffer (signaled by an event) if it wants to reuse the buffer to render another frame, or it can use another buffer to render the new frame, and, when the rendering is finished, bind this new buffer to the surface and commit its contents.: 7  The procedure used for rendering, including the number of buffers involved and their management, is entirely under the client control.: 7 
Comparison with other window systems
Differences between Wayland and X
There are several differences between Wayland and X with regard to performance, code maintainability, and security:
Compatibility with X
XWayland is an X Server running as a Wayland client, and thus is capable of displaying native X11 client applications in a Wayland compositor environment. This is similar to the way XQuartz runs X applications in macOS’s native windowing system. The goal of XWayland is to facilitate the transition from X Window System to Wayland environments, providing a way to run unported applications in the meantime. XWayland was mainlined into X.Org Server version 1.16.
Widget toolkits such as Qt5 and GTK3 can switch their graphical back-end at run time, allowing users to choose at load time whether they want to run the application over X or over Wayland. Qt 5 provides the -platform command-line option to that effect, whereas GTK 3 lets users select the desired GDK back-end by setting the GDK_BACKEND Unix environment variable.
Wayland compositors
Display servers that implement the Wayland display server protocol are also called Wayland compositors because they additionally perform the task of a compositing window manager.
Weston
Weston is the reference implementation of a Wayland compositor also developed by the Wayland project. It is written in C and published under the MIT License. Weston has official support for only the Linux operating system due to Weston's dependence on certain features of the Linux kernel, such as kernel mode-setting, Graphics Execution Manager (GEM), and udev, which have not been implemented in other Unix-like operating systems. When running on Linux, handling of the input hardware relies on evdev, while the handling of buffers relies on Generic Buffer Management (GBM). However, in 2013 a prototype port of Weston to FreeBSD was announced.
Weston supports High-bandwidth Digital Content Protection (HDCP).
Weston relies on GEM to share application buffers between the compositor and applications. It contains a plug-in system of "shells" for common desktop features like docks and panels. Clients are responsible for the drawing of their window borders and their decorations. For rendering, Weston can use OpenGL ES or the pixman library to do software rendering. The full OpenGL implementation is not used, because on most current systems, installing the full OpenGL libraries would also install GLX and other X Window System support libraries as dependencies.
A remote access interface for Weston was proposed in October 2013 by a RealVNC employee.
Maynard
Maynard is a graphical shell and has been written as a plug-in for Weston, just as the GNOME Shell has been written as a plug-in to Mutter.
The Raspberry Pi Foundation in collaboration with Collabora released Maynard and work on improving performance and memory consumption.
libinput
The Weston code for handling input devices (keyboards, pointers, touch screens, etc.) was split into its own separate library, called libinput, for which support was first merged in Weston 1.5.
Libinput handles input devices for multiple Wayland compositors and also provides a generic X.Org Server input driver. It aims to provide one implementation for multiple Wayland compositors with a common way to handle input events while minimizing the amount of custom input code compositors need to include. libinput provides device detection (via udev), device handling, input device event processing and abstraction.
Version 1.0 of libinput followed version 0.21, and included support for tablets, button sets and touchpad gestures. This version will maintain stable API/ABI.
As GNOME/GTK and KDE Frameworks 5 have mainlined the required changes, Fedora 22 will replace X.Org's evdev and Synaptics drivers with libinput.
With version 1.16, the X.Org Server obtained support for the libinput library in form of a wrapper called xf86-input-libinput.
Wayland Security Module
Wayland Security Module is a proposition that resembles the Linux Security Module interface found in the Linux kernel.
Some applications (especially the ones related to accessibility) require privileged capabilities that should work across different Wayland compositors. Currently, applications under Wayland are generally unable to perform any sensitive tasks such as taking screenshots or injecting input events. Wayland developers are actively looking for feasible ways to handle privileged clients securely and then designing privileged interfaces for them.
Wayland Security Module is a way to delegate security decisions within the compositor to a centralized security decision engine.
Adoption
The Wayland protocol is designed to be simple so that additional protocols and interfaces need to be defined and implemented to achieve a holistic windowing system. As of July 2014 these additional interfaces were being worked on. So, while the toolkits already fully support Wayland, the developers of the graphical shells are cooperating with the Wayland developers creating the necessary additional interfaces.
Desktop Linux distributions
As of 2020 most Linux distributions support Wayland out of the box. Some notable examples are:
Notable early adopter:
Toolkit support
Toolkits supporting Wayland include the following:
Desktop environments
Desktop environments in process of being ported from X to Wayland include GNOME, KDE Plasma 5 and Enlightenment.
In November 2015, Enlightenment e20 was announced with full Wayland support. GNOME 3.20 was the first version to have a full Wayland session. GNOME 3.22 included much improved Wayland support across GTK, Mutter, and GNOME Shell. GNOME 3.24 shipped support for the proprietary NVidia drivers under Wayland.
Wayland support for KDE Plasma was delayed until the release of Plasma 5, though previously KWin 4.11 got an experimental Wayland support. The version 5.4 of Plasma was the first with a Wayland session. During 2020 Klipper was ported to Wayland and the next 5.20 release in October 2020 has the goal to improve screen casting and recording.
Other software
Other software supporting Wayland includes the following:
Mobile and embedded hardware
Mobile and embedded hardware supporting Wayland includes the following:
History
Kristian Høgsberg, a Linux graphics and X.Org developer who previously worked on AIGLX and DRI2, started Wayland as a spare-time project in 2008 while working for Red Hat. His stated goal was a system in which "every frame is perfect, by which I mean that applications will be able to control the rendering enough that we'll never see tearing, lag, redrawing or flicker." Høgsberg was driving through the town of Wayland, Massachusetts when the underlying concepts "crystallized", hence the name.
In October 2010, Wayland became a freedesktop.org project. As part of the migration the prior Google Group was replaced by the wayland-devel mailing list as the project's central point of discussion and development.
The Wayland client and server libraries were initially released under the MIT License, while the reference compositor Weston and some example clients used the GNU General Public License version 2. Later all the GPL code was relicensed under the MIT license "to make it easier to move code between the reference implementation and the actual libraries". In 2015 it was discovered that the license text used by Wayland was a slightly different and older version of the MIT license, and the license text was updated to the current version used by the X.Org project (known as MIT Expat License).
Wayland works with all Mesa-compatible drivers with DRI2 support as well as Android drivers via the Hybris project.