Julia (programming language)
Julia is a high-level, dynamic programming language. Its features are well suited for numerical analysis and computational science.
Distinctive aspects of Julia's design include a type system with parametric polymorphism in a dynamic programming language; with multiple dispatch as its core programming paradigm. Julia supports concurrent, (composable) parallel and distributed computing (with or without using MPI or the built-in corresponding to "OpenMP-style" threads), and direct calling of C and Fortran libraries without glue code. Julia uses a just-in-time (JIT) compiler that is referred to as "just-ahead-of-time" (JAOT) in the Julia community, as Julia compiles all code (by default) to machine code before running it.
Julia is garbage-collected, uses eager evaluation, and includes efficient libraries for floating-point calculations, linear algebra, random number generation, and regular expression matching. Many libraries are available, including some (e.g., for fast Fourier transforms) that were previously bundled with Julia and are now separate.
Several development tools support coding in Julia, such as integrated development environments (e.g. for Microsoft's Visual Studio Code, an extension is available providing debugging and linting support); with integrated tools, e.g. a profiler (and flame graph support available for the built-in one), debugger, and the Rebugger.jl package "supports repeated-execution debugging" and more.
Julia works with other languages, calling C has special support,  and with use of extra packages, e.g. for working with Python, R, Rust, C++, SQL and to work with or even to compile to JavaScript.
Julia can be compiled to binary executables using a package  for it supporting all Julia features. Small binary executables can also be made using a different package  but then the Julia runtime isn't included in the executable, e.g. down to  9 KB (then without e.g. the garbage collector since it's part of Julia's runtime, i.e. with similar limited capabilities to the C language), for computers or even microcontrollers with 2 KB of RAM. By default, Julia code depends on the Julia runtime to support all Julia features, e.g. threading, but some (non-idiomatic, to smaller or larger degree) Julia code can be compiled to small executables (with limited Julia capabilities). In both cases no source code needs to be distributed.
History
Work on Julia was started in 2009, by Jeff Bezanson, Stefan Karpinski, Viral B. Shah, and Alan Edelman, who set out to create a free language that was both high-level and fast. On 14 February 2012, the team launched a website with a blog post explaining the language's mission. In an interview with InfoWorld in April 2012, Karpinski said of the name "Julia": "There's no good reason, really. It just seemed like a pretty name." Bezanson said he chose the name on the recommendation of a friend, then years later wrote:
In the 10 years since the 2012 launch of pre-1.0 Julia, the community has grown. The Julia package ecosystem has over 11.8 million lines of code (including docs and tests). The JuliaCon academic conference for Julia users and developers has been held annually since 2014 with JuliaCon2020 welcoming over 28,900 unique viewers, and then JuliaCon2021 breaking all previous records (with more than 300 JuliaCon2021 presentations available for free on YouTube, up from 162 the year before), and 43,000 unique viewers during the conference.
Three of the Julia co-creators are the recipients of the 2019 James H. Wilkinson Prize for Numerical Software (awarded every four years) "for the creation of Julia, an innovative environment for the creation of high-performance tools that enable the analysis and solution of computational science problems." Also, Alan Edelman, professor of applied mathematics at MIT, has been selected to receive the 2019 IEEE Computer Society Sidney Fernbach Award "for outstanding breakthroughs in high-performance computing, linear algebra, and computational science and for contributions to the Julia programming language."
Both Julia 0.7 and version 1.0 were released on 8 August 2018. Work on Julia 0.7 was a "huge undertaking" (e.g., because of an "entirely new optimizer"), and some changes were made to semantics, e.g. the iteration interface was simplified; and the syntax changed a little (with the syntax now stable, and same for 1.x and 0.7).
Julia 1.1 was released in January 2019 with a new "exception stack" feature.
Julia 1.2 was released in August 2019 with some built-in support for web browsers.
Julia 1.3 added composable multi-threaded parallelism and a binary artifacts system for Julia packages.
Julia 1.4 added syntax for generic array indexing to handle e.g. 0-based arrays. The memory model was also changed.
Julia 1.5 released in August 2020 added record and replay debugging support, for Mozilla's rr tool.  The release changed the behavior in the REPL (soft scope) to the one used in Jupyter, but fully compatible with non-REPL code. Most of the thread API was marked as stable, and with this release "arbitrary immutable objects—regardless of whether they have fields that reference mutable objects or not—can now be stack allocated", reducing heap allocations, e.g. views are no longer allocating.  Julia 1.5 targeted so-called "time-to-first-plot" performance, in general, the speed of compilation itself (as opposed to performance of the generated code), and adds tools for developers to improve package loading.
Julia 1.6 was the largest release since 1.0, faster on many fronts, e.g. introduced parallel precompilation and faster loading of packages, in some cases "50x speedup in load times for large trees of binary artifacts".
As of version 1.7 Julia development is back to time-based releases.
Julia 1.7.0 was released in November 2021, with many changes, e.g. a new faster random-number generator.
Julia 1.7.3 was released on 25 May 2022, fixing some issues, including at least one security update.
Julia 1.8 has been released (and 1.8.1 and 1.8.2 as followup on 29 September 2022, both fixing bugs and invalidations, thus compiling faster), with improvements for distributing Julia programs without source code,  and compiler speedup, in some cases by 25%,  and more controllable inlining (i.e. now also allowing applying @inline at the call site, not just on the function itself) and Julia 1.9 is the next milestone, it and the milestones for 1.10, 1.11, 1.12 and 2.0 currently have no set due dates.
JuliaCon
Since 2014, the Julia Community has hosted an annual Julia Conference focused on developers and users. The first JuliaCon took place in Chicago and kickstarted the annual occurrence of the conference. Since 2014, the conference has taken place across a number of locations including MIT and the University of Maryland, Baltimore. The event audience has grown from a few dozen people to over 28,900 unique attendees during JuliaCon 2020, which took place virtually. JuliaCon 2021 also took place virtually with keynote addresses from professors William Kahan (the primary architect of the IEEE 754 floating-point standard, which his keynote is about, that virtually all CPUs use and languages, including Julia), and Jan Vitek, Xiaoye Sherry Li, and Soumith Chintala (co-creator of PyTorch). JuliaCon grew to 43,000 unique attendees and more than 300 presentations (still freely accessible, plus for older years). JuliaCon 2022 will also be virtual held between July 27 and July 29, 2022, for the first time in several languages, not just in English.
Sponsors
The Julia language became a NumFOCUS fiscally sponsored project in 2014 in an effort to ensure the project's long-term sustainability. Jeremy Kepner at MIT Lincoln Laboratory was the founding sponsor of the Julia project in its early days. In addition, funds from the Gordon and Betty Moore Foundation, the Alfred P. Sloan Foundation, Intel, and agencies such as NSF, DARPA, NIH, NASA, and FAA have been essential to the development of Julia. Mozilla, the maker of Firefox web browser, with its research grants for H1 2019, sponsored "a member of the official Julia team" for the project "Bringing Julia to the Browser", meaning to Firefox  and other web browsers. The Julia language is also supported by individual donors on GitHub.
Julia company
JuliaHub, Inc. was founded in 2015 as Julia Computing, Inc. by Viral B. Shah, Deepak Vinchhi, Alan Edelman, Jeff Bezanson, Stefan Karpinski and Keno Fischer.
In June 2017, Julia Computing raised US$4.6 million in seed funding from General Catalyst and Founder Collective, the same month was "granted $910,000 by the Alfred P. Sloan Foundation to support open-source Julia development, including $160,000 to promote diversity in the Julia community", and in December 2019 the company got $1.1 million funding from the US government to "develop a neural component machine learning tool to reduce the total energy consumption of heating, ventilation, and air conditioning (HVAC) systems in buildings". In July 2021, Julia Computing announced they raised a $24 million Series A round led by Dorilton Ventures, which also owns Formula 1 team Williams Racing, that partnered with Julia Computing. Williams' Commercial Director said: "Investing in companies building best-in-class cloud technology is a strategic focus for Dorilton and Julia's versatile platform, with revolutionary capabilities in simulation and modelling, is hugely relevant to our business. We look forward to embedding Julia Computing in the world's most technologically advanced sport".
Language features
Julia is a general-purpose programming language, while also originally designed for numerical/technical computing.
It is also useful for low-level systems programming, as a specification language, High-level Synthesis (HLS) tool (for hardware, e.g. FPGAs), and for web programming at both server and client side.
The main features of the language are:
Multiple dispatch (also termed multimethods in Lisp) is a generalization of single dispatch –  the polymorphic mechanism used in common object-oriented programming (OOP) languages, such as Python, C++, Java, JavaScript, and Smalltalk –  that uses inheritance. In Julia, all concrete types are subtypes of abstract types, directly or indirectly subtypes of the Any type, which is the top of the type hierarchy. Concrete types can not themselves be subtyped the way they can in other languages; composition is used instead (see also inheritance vs subtyping).
By default, the Julia runtime must be pre-installed as user-provided source code is run. Alternatively, a standalone executable that needs no Julia source code can be built with e.g. PackageCompiler.jl.
Julia's syntactic macros (used for metaprogramming), like Lisp macros, are more powerful than text-substitution macros used in the preprocessor of some other languages such as C, because they work at the level of abstract syntax trees (ASTs). Julia's macro system is hygienic, but also supports deliberate capture when desired (like for anaphoric macros) using the esc construct.
Julia draws inspiration from various dialects of Lisp, including Scheme and Common Lisp, and it shares many features with Dylan, also a multiple-dispatch-oriented dynamic language (which features an ALGOL-like free-form infix syntax rather than a Lisp-like prefix syntax, while in Julia "everything" is an expression), and with Fortress, another numerical programming language (which features multiple dispatch and a sophisticated parametric type system). While Common Lisp Object System (CLOS) adds multiple dispatch to Common Lisp, not all functions are generic functions.
In Julia, Dylan, and Fortress, extensibility is the default, and the system's built-in functions are all generic and extensible. In Dylan, multiple dispatch is as fundamental as it is in Julia: all user-defined functions and even basic built-in operations like + are generic. Dylan's type system, however, does not fully support parametric types, which are more typical of the ML lineage of languages. By default, CLOS does not allow for dispatch on Common Lisp's parametric types; such extended dispatch semantics can only be added as an extension through the CLOS Metaobject Protocol. By convergent design, Fortress also features multiple dispatch on parametric types; unlike Julia, however, Fortress is statically rather than dynamically typed, with separate compiling and executing phases. The language features are summarized in the following table:
An example of the extensibility of Julia, the Unitful.jl package adds support for physical units of measurement to the language.
Interaction
The Julia official distribution includes an interactive command-line read–eval–print loop (REPL), with a searchable history, tab completion, and dedicated help and shell modes, which can be used to experiment and test code quickly. The following fragment represents a sample session example where strings are concatenated automatically by println:
The REPL gives user access to the system shell and to help mode, by pressing ; or ? after the prompt (preceding each command), respectively. It also keeps the history of commands, including between sessions. Code can be tested inside Julia's interactive session or saved into a file with a .jl extension and run from the command line by typing:
Julia uses UTF-8, e.g. for source code, meaning also allowing as an option common math symbols for many operators, such as ∈ for the in operator, typable with \in then pressing Tab ↹ (i.e. uses LaTeX codes, or also possible by simply copy-pasting, e.g. √ and ∛ possible for sqrt and cbrt functions). Julia has support for Unicode 14.0 (from 2021, and 1.9-DEV supports the latest Unicode 15.0), for the languages of the world, even for source code, e.g. variable names (while not using English isn't recommended for code for others to read e.g. package names).
Julia is supported by Jupyter, an online interactive "notebooks" environment, and Pluto.jl, a "reactive notebook" (where notebooks are saved as pure Julia files), a possible replacement for the former kind.
The REPL can be extended with additional modes, and has been with packages, e.g. with an SQL mode, for database access, and RCall.jl adds an R mode, to work with the R language.
Use with other languages
Julia is in practice interoperable with other languages (e.g. majority of top 10–20 languages in popular use). Julia's ccall keyword is used to call C-exported or Fortran shared library functions individually, and packages are available to allow calling other languages e.g. Python, R, MATLAB, C# (and other .NET languages with DotNET.jl), JavaScript, Java (and other JVM languages, such as Scala with JavaCall.jl). And packages for other languages allow to call to Julia, e.g. from Python, R, Rust, or Ruby, such as with pyjulia and PythonCall.jl/juliacall for Python and a different JuliaCall package for R. Julia has also been used for hardware, i.e. to compile to VHDL, as a High-level Synthesis (HLS) tool (for e.g. FPGAs).
Julia has packages supporting markup languages such as HTML (and also for HTTP), XML, JSON and BSON, and for databases (such as PostgreSQL, Mongo, Oracle, including for TimesTen, MySQL, SQLite, Microsoft SQL Server, Amazon Redshift, Vertica, ODBC) and web use in general.
Package system
Julia has a built-in package manager and includes a default registry system. Packages are most often distributed as source code hosted on GitHub, though alternatives can also be used just as well. Packages can also be installed as binaries, using artifacts. Julia's package manager is used to query and compile packages, as well as managing environments. Federated package registries are supported, allowing registries other than the official to be added locally.
Implementation
Julia's core is implemented in Julia and C, together with C++ for the LLVM dependency. The code parsing and code-lowering are implemented in FemtoLisp, a Scheme dialect (that parser can however be switched out at runtime, with the pure-Julia package JuliaSyntax.jl, a drop-in, faster replacement, usually, and it "greatly improves parser error messages in various cases", thus it's being considered as an addition to Julia, first as a non-default option in 1.10.0, but can already be used in older versions). A non-default parser package Parser.jl (for e.g. much faster floating-point number parsing on Windows) is available, already used indirectly by some packages, but is also being considered for inclusion into Julia. The LLVM compiler infrastructure project is used as the back end for generation of 64-bit or 32-bit optimized machine code depending on the platform Julia runs on. With some exceptions (e.g., PCRE, which is being considered for removal in Julia 2.0; Julia already has alternative regex libraries, e.g. RE2.jl for Google's re2, StrRegex.jl and ReadableRegex.jl), the standard library is implemented in Julia. A very notable aspect of Julia's implementation is its speed, which is often within a factor of two relative to fully optimized C code (and thus often an order of magnitude faster than Python or R). Development of Julia began in 2009 and an open-source version was publicized in February 2012.
Current and future platforms
Julia has tier 1 macOS support, meaning for Intel-based Macs, but also for the new Apple M1-based Macs, by either running in Rosetta 2 emulation, or, while then, with tier 2 native (non-Rosetta) support with Julia 1.8 (unlike the older LTS version of Julia which only has tier 3 (experimental) support; Windows on ARM has no official support yet). The work on that support (i.e. without emulation) is mostly done, and many programs work with Julia 1.8.0. Julia was prior to 1.8.0 claimed to work "ok" on M1 Macs (at reduced performance) through the (automatic) use of Rosetta 2 (that needs to emulate Julia).
Since Julia uses JIT, Julia generates native machine code directly, before a function is first run (i.e. a different approach than compiling to bytecode, that you distribute by default, to be run on a virtual machine (VM), as with e.g. Java/JVM; then translated from the bytecode while running, as done by Dalvik on older versions of Android).
Julia has four support tiers. All IA-32 processors completely implementing the i686 subarchitecture are supported and all 64-bit x86-64 (aka amd64), i.e. all less than about a decade old are supported. ARMv8 (AArch64) processors are supported on second tier, and ARMv7 and ARMv6 (AArch32) are supported with some caveats (lower tier) for Julia 1.0.x and also had official executables for later versions, while 32-bit ARM support was later downgraded to tier 3 (however, unofficial binaries are available for Julia 1.5.1). Hundreds of packages are GPU-accellerated: CUDA (i.e. Nvidia GPUs; implementing PTX) has tier 1 support, with the help of an external package. There are also additionally packages supporting other accelerators, such as Google's TPUs, and some Intel (integrated) GPUs, through oneAPI.jl, and AMD's GPUs have support with e.g. OpenCL; and experimental support for the AMD ROCm stack. Julia's downloads page provides executables (and source) for all the officially supported platforms.
On some platforms, Julia may need to be compiled from source code (e.g., the original Raspberry Pi), with specific build options, which has been done and unofficial pre-built binaries (and build instructions) are available. Julia has been built 
for several ARM platforms, from small Raspberry Pis to (recent) top-1 supercomputer Fugaku's ARM-based A64FX. PowerPC (64-bit) has tier 3 support, meaning it "may or may not build".

Julia is now supported in Raspbian while support is better for newer Pis, e.g., those with ARMv7 or newer; the Julia support is promoted by the Raspberry Pi Foundation.
There is also support for web browsers/JavaScript through JSExpr.jl; and the alternative language of web browsers, WebAssembly, has minimal support for several upcoming external Julia projects.



Julia can compile to ARM; thus, in theory, Android apps can be made with the NDK, but for now Julia has been made to run under Android only indirectly, i.e. with a Ubuntu chroot on Android.
While Julia requires an operating system by default, and has no official support to run without or on embedded system platforms like Arduino, Julia code has still been run, with some limitations, on a baremetal 16 MHz 8-bit AVR-microcontroller Arduino with 2 KB RAM (plus 32 KB of flash memory).
Adoption
Julia has been adopted by many universities including MIT, Stanford, and UC Berkeley. Large private firms across many sectors have adopted the language including Amazon, IBM, BlackRock, JP Morgan, ASML, and many of the largest pharma companies. Julia has also been used in government agencies like NASA and the FAA as well as every US national energy laboratory.
Scientific computing
Other notable uses
See also
Notes
References
Further reading