Apollo Guidance Computer
The Apollo Guidance Computer (AGC) was a digital computer produced for the Apollo program that was installed on board each Apollo command module (CM) and Apollo Lunar Module (LM). The AGC provided computation and electronic interfaces for guidance, navigation, and control of the spacecraft. The AGC was the first computer based on silicon integrated circuits. The computer's performance was comparable to the first generation of home computers from the late 1970s, such as the Apple II, TRS-80, and Commodore PET.
The AGC has a 16-bit word length, with 15 data bits and one parity bit. Most of the software on the AGC is stored in a special read-only memory known as core rope memory, fashioned by weaving wires through and around magnetic cores, though a small amount of read/write core memory is available.
Astronauts communicated with the AGC using a numeric display and keyboard called the DSKY (for "display and keyboard", pronounced "DIS-kee"). The AGC and its DSKY user interface were developed in the early 1960s for the Apollo program by the MIT Instrumentation Laboratory and first flew in 1966.
Operation
Astronauts manually flew Project Gemini with control sticks, but computers flew most of Project Apollo except briefly during lunar landings. Each Moon flight carried two AGCs, one each in the command module and the Apollo Lunar Module, with the exception of Apollo 8 which did not need a lunar module for its lunar orbit mission. The AGC in the command module was the center of its guidance, navigation and control (GNC) system. The AGC in the lunar module ran its Apollo PGNCS (primary guidance, navigation and control system), with the acronym pronounced as pings.
Each lunar mission had two additional computers:
Design
The AGC was designed at the MIT Instrumentation Laboratory under Charles Stark Draper, with hardware design led by Eldon C. Hall. Early architectural work came from J. H. Laning Jr., Albert Hopkins, Richard Battin, Ramon Alonso,
 and Hugh Blair-Smith.
The flight hardware was fabricated by Raytheon, whose Herb Thaler was also on the architectural team.
Logic hardware
Following the use of integrated circuit (IC) chips in the Interplanetary Monitoring Platform (IMP) in 1963, IC technology was later adopted for the AGC. The Apollo flight computer was the first computer to use silicon IC chips.
While the Block I version used 4,100 ICs, each containing a single three-input NOR gate, the later Block II version (used in the crewed flights) used about 2,800 ICs, mostly dual three-input NOR gates and smaller numbers of expanders and sense amplifiers.: 27, 266  The ICs, from Fairchild Semiconductor, were implemented using resistor–transistor logic (RTL) in a flat-pack. They were connected via wire wrap, and the wiring was then embedded in cast epoxy plastic.: 129 
The use of a single type of IC (the dual NOR3) throughout the AGC avoided problems that plagued another early IC computer design, the Minuteman II guidance computer, which used a mix of diode–transistor logic and diode logic gates. NOR gates are universal logic gates from which any other gate can be made, though at the cost of using more gates.
Memory
The computer had 2048 words of erasable magnetic-core memory and 36,864 words of read-only core rope memory.: 27, 90–93  Both had cycle times of 11.72 microseconds.: 27  The memory word length was 16 bits: 15 bits of data and one odd-parity bit. The CPU-internal 16-bit word format was 14 bits of data, one overflow bit, and one sign bit (ones' complement representation).: 35–37 
DSKY interface
The user interface to the AGC was the DSKY, standing for display and keyboard and usually pronounced "DIS-kee". It has an array of indicator lights, numeric displays, and a calculator-style keyboard. Commands were entered numerically, as two-digit numbers: Verb, and Noun. Verb described the type of action to be performed and Noun specified which data were affected by the action specified by the Verb command.
Each digit was displayed via a green (specified as 530 nm) high-voltage electroluminescent seven-segment display; these were driven by electromechanical relays, limiting the update rate. Three five-digit signed numbers could also be displayed in octal or decimal, and were typically used to display vectors such as space craft attitude or a required velocity change (delta-V). Although data was stored internally in metric units, they were displayed as United States customary units. This calculator-style interface was the first of its kind.
The command module has two DSKYs connected to its AGC: one located on the main instrument panel and a second located in the lower equipment bay near a sextant used for aligning the inertial guidance platform. The lunar module had a single DSKY for its AGC. A flight director attitude indicator (FDAI), controlled by the AGC, was located above the DSKY on the commander's console and on the LM.
Timing
The AGC timing reference came from a 2.048 MHz crystal clock. The clock was divided by two to produce a four-phase 1.024 MHz clock which the AGC used to perform internal operations. The 1.024 MHz clock was also divided by two to produce a 512 kHz signal called the master frequency; this signal was used to synchronize external Apollo spacecraft systems.
The master frequency was further divided through a scaler, first by five using a ring counter to produce a 102.4 kHz signal. This was then divided by two through 17 successive stages called F1 (51.2 kHz) through F17 (0.78125 Hz). The F10 stage (100 Hz) was fed back into the AGC to increment the real-time clock and other involuntary counters using Pinc (discussed below). The F17 stage was used to intermittently run the AGC when it was operating in the standby mode.
Central registers
The AGC had four 16-bit registers for general computational use, called the central registers:
There were also four locations in core memory, at addresses 20–23, dubbed editing locations because whatever was stored there would emerge shifted or rotated by one bit position, except for one that shifted right seven bit positions, to extract one of the seven-bit interpretive op. codes that were packed two to a word. This was common to Block I and Block II AGCs.
Other registers
The AGC had additional registers that were used internally in the course of operation:
Instruction set
The instruction format used 3 bits for opcode, and 12 bits for address. Block I had 11 instructions: TC, CCS, INDEX, XCH, CS, TS, AD, and MASK (basic), and SU, MP, and DV (extra). The first eight, called basic instructions, were directly accessed by the 3-bit op. code. The final three were denoted as extracode instructions because they were accessed by performing a special type of TC instruction (called EXTEND) immediately before the instruction.
The Block I AGC instructions consisted of the following:
Instructions were implemented in groups of 12 steps, called timing pulses. The timing pulses were named TP1 through TP12. Each set of 12 timing pulses was called an instruction subsequence. Simple instructions, such as TC, executed in a single subsequence of 12 pulses. More complex instructions required several subsequences. The multiply instruction (MP) used 8 subsequences: an initial one called MP0, followed by an MP1 subsequence which was repeated 6 times, and then terminated by an MP3 subsequence. This was reduced to 3 subsequences in Block II.
Each timing pulse in a subsequence could trigger up to 5 control pulses. The control pulses were the signals which did the actual work of the instruction, such as reading the contents of a register onto the bus, or writing data from the bus into a register.
Memory
Block I AGC memory was organized into 1 kiloword banks. The lowest bank (bank 0) was erasable memory (RAM). All banks above bank 0 were fixed memory (ROM). Each AGC instruction had a 12-bit address field. The lower bits (1-10) addressed the memory inside each bank. Bits 11 and 12 selected the bank: 00 selected the erasable memory bank; 01 selected the lowest bank (bank 1) of fixed memory; 10 selected the next one (bank 2); and 11 selected the Bank register that could be used to select any bank above 2. Banks 1 and 2 were called fixed-fixed memory, because they were always available, regardless of the contents of the Bank register. Banks 3 and above were called fixed-switchable because the selected bank was determined by the bank register.
The Block I AGC initially had 12 kilowords of fixed memory, but this was later increased to 24 kilowords. Block II had 36 kilowords of fixed memory and 2 kilowords of erasable memory.
The AGC transferred data to and from memory through the G register in a process called the memory cycle. The memory cycle took 12 timing pulses (11.72 μs). The cycle began at timing pulse 1 (TP1) when the AGC loaded the memory address to be fetched into the S register. The memory hardware retrieved the data word from memory at the address specified by the S register. Words from erasable memory were deposited into the G register by timing pulse 6 (TP6); words from fixed memory were available by timing pulse 7. The retrieved memory word was then available in the G register for AGC access during timing pulses 7 through 10. After timing pulse 10, the data in the G register was written back to memory.
The AGC memory cycle occurred continuously during AGC operation. Instructions needing memory data had to access it during timing pulses 7–10. If the AGC changed the memory word in the G register, the changed word was written back to memory after timing pulse 10. In this way, data words cycled continuously from memory to the G register and then back again to memory.
The lower 15 bits of each memory word held AGC instructions or data, with each word being protected by a 16th odd parity bit. This bit was set to 1 or 0 by a parity generator circuit so a count of the 1s in each memory word would always produce an odd number. A parity checking circuit tested the parity bit during each memory cycle; if the bit didn't match the expected value, the memory word was assumed to be corrupted and a parity alarm panel light was illuminated.
Interrupts and involuntary counters
The AGC had five vectored interrupts:
The AGC responded to each interrupt by temporarily suspending the current program, executing a short interrupt service routine, and then resuming the interrupted program.
The AGC also had 20 involuntary counters. These were memory locations which functioned as up/down counters, or shift registers. The counters would increment, decrement, or shift in response to internal inputs. The increment (Pinc), decrement (Minc), or shift (Shinc) was handled by one subsequence of microinstructions inserted between any two regular instructions.
Interrupts could be triggered when the counters overflowed. The T3rupt and Dsrupt interrupts were produced when their counters, driven by a 100 Hz hardware clock, overflowed after executing many Pinc subsequences. The Uprupt interrupt was triggered after its counter, executing the Shinc subsequence, had shifted 16 bits of uplink data into the AGC.
Standby mode
The AGC had a power-saving mode controlled by a standby allowed switch. This mode turned off the AGC power, except for the 2.048 MHz clock and the scaler. The F17 signal from the scaler turned the AGC power and the AGC back on at 1.28 second intervals. In this mode, the AGC performed essential functions, checked the standby allowed switch, and, if still enabled, turned off the power and went back to sleep until the next F17 signal.
In the standby mode, the AGC slept most of the time; therefore it was not awake to perform the Pinc instruction needed to update the AGC's real time clock at 10 ms intervals. To compensate, one of the functions performed by the AGC each time it awoke in the standby mode was to update the real time clock by 1.28 seconds.
The standby mode was designed to reduce power by 5 to 10 W (from 70 W) during midcourse flight when the AGC was not needed. However, in practice, the AGC was left on during all phases of the mission and this feature was never used.
Data buses
The AGC had a 16-bit read bus and a 16-bit write bus. Data from central registers (A, Q, Z, or LP), or other internal registers could be gated onto the read bus with a control signal. The read bus connected to the write bus through a non-inverting buffer, so any data appearing on the read bus also appeared on the write bus. Other control signals could copy write bus data back into the registers.
Data transfers worked like this: To move the address of the next instruction from the B register to the S register, an RB (read B) control signal was issued; this caused the address to move from register B to the read bus, and then to the write bus. A WS (write S) control signal moved the address from the write bus into the S register.
Several registers could be read onto the read bus simultaneously. When this occurred, data from each register was inclusive-ORed onto the bus. This inclusive-OR feature was used to implement the Mask instruction, which was a logical AND operation. Because the AGC had no native ability to do a logical AND, but could do a logical OR through the bus and could complement (invert) data through the C register, De Morgan's theorem was used to implement the equivalent of a logical AND. This was accomplished by inverting both operands, performing a logical OR through the bus, and then inverting the result.
Software
AGC software was written in AGC assembly language and stored on rope memory. The bulk of the software was on read-only rope memory and thus could not be changed in operation, but some key parts of the software were stored in standard read-write magnetic-core memory and could be overwritten by the astronauts using the DSKY interface, as was done on Apollo 14.
A simple real-time operating system designed by J. Halcombe Laning consisting of the 'Exec', a batch job-scheduling using cooperative multi-tasking, and an interrupt-driven pre-emptive scheduler called the 'Waitlist' which scheduled timer-driven 'tasks', controlled the computer. Tasks were short threads of execution which could reschedule themselves for re-execution on the Waitlist, or could kick off a longer operation by starting a 'job' with the Exec. Calculations were carried out using the metric system, but display readouts were in units of feet, feet per second, and nautical miles – units that the Apollo astronauts were accustomed to.
The AGC  had a sophisticated software interpreter, developed by the MIT Instrumentation Laboratory, that implemented a virtual machine with more complex and capable pseudo-instructions than the native AGC. These instructions simplified the navigational programs. Interpreted code, which featured double precision trigonometric, scalar and vector arithmetic (16 and 24-bit), even an MXV (matrix × vector) instruction, could be mixed with native AGC code. While the execution time of the pseudo-instructions was increased (due to the need to interpret these instructions at runtime) the interpreter provided many more instructions than AGC natively supported and the memory requirements were much lower than in the case of adding these instructions to the AGC native language which would require additional memory built into the computer (at that time the memory capacity was very expensive). The average pseudo-instruction required about 24 ms to execute. The assembler, named YUL for an early prototype Christmas Computer, enforced proper transitions between native and interpreted code.
A set of interrupt-driven user interface routines called 'Pinball' provided keyboard and display services for the jobs and tasks running on the AGC. A set of user-accessible routines were provided to let the astronauts display the contents of various memory locations in octal or decimal in groups of 1, 2, or 3 registers at a time. 'Monitor' routines were provided so the operator could initiate a task to periodically redisplay the contents of certain memory locations. Jobs could be initiated.
The design principles developed for the AGC by MIT Instrumentation Laboratory, directed in late 1960s by Charles Draper, became foundational to software engineering—particularly for the design of more reliable systems that relied on asynchronous software, priority scheduling, testing, and human-in-the-loop decision capability. When the design requirements for the AGC were defined, necessary software and programming techniques did not exist so they had to be designed from scratch. Many of the trajectory and guidance algorithms used were based on earlier work by Richard Battin. The first command module flight was controlled by a software package called CORONA whose development was led by Alex Kosmala. Software for lunar missions consisted of COLOSSUS for the command module, whose development was led by Frederic Martin, and LUMINARY on the lunar module led by George Cherry. Details of these programs were implemented by a team under the direction of Margaret Hamilton. Hamilton was very interested in how the astronauts would interact with the software and predicted the types of errors that could occur due to human error. In total, software development on the project comprised 1400 person-years of effort, with a peak workforce of 350 people. In 2016, Hamilton received the Presidential Medal of Freedom for her role in creating the flight software.
The Apollo Guidance Computer software influenced the design of Skylab, Space Shuttle and early fly-by-wire fighter aircraft systems.
The Apollo Guidance computer has been called "The fourth astronaut" for its role in helping the three astronauts who relied on it Neil Armstrong, Buzz Aldrin and Michael Collins.
Block II
A Block II version of the AGC was designed in 1966. It retained the basic Block I architecture, but increased erasable memory from 1 to 2 kilowords. Fixed memory was expanded from 24 to 36 kilowords. Instructions were expanded from 11 to 34 and I/O channels were implemented to replace the I/O registers on Block I. The Block II version is the one that actually flew to the moon. Block I was used during the uncrewed Apollo 4 and 6 flights, and was on board the ill-fated Apollo 1.
The decision to expand the memory and instruction set for Block II, but to retain the Block I's restrictive three-bit op. code and 12-bit address had interesting design consequences. Various tricks were employed to squeeze in additional instructions, such as having special memory addresses which, when referenced, would implement a certain function. For instance, an INDEX to address 25 triggered the RESUME instruction to return from an interrupt. Likewise, INDEX 17 performed an INHINT instruction (inhibit interrupts), while INDEX 16 reenabled them (RELINT). Other instructions were implemented by preceding them with a special version of TC called EXTEND. The address spaces were extended by employing the Bank (fixed) and Ebank (erasable) registers, so the only memory of either type that could be addressed at any given time was the current bank, plus the small amount of fixed-fixed memory and the erasable memory. In addition, the bank register could address a maximum of 32 kilowords, so an Sbank (super-bank) register was required to access the last 4 kilowords. All across-bank subroutine calls had to be initiated from fixed-fixed memory through special functions to restore the original bank during the return: essentially a system of far pointers.
The Block II AGC also has the EDRUPT instruction (the name is a contraction of Ed's Interrupt, after Ed Smally, the programmer who requested it). This instruction does not generate an interrupt, rather it performs two actions that are common to interrupt processing. The first action, inhibits further interrupts (and requires a RESUME instruction to enable them again). In the second action, the ZRUPT register is loaded with the current value of the program counter (Z). It was only used once in the Apollo software, for setting up the DAP cycle termination sequence in the Digital Autopilot of the lunar module. It is believed to be responsible for problems emulating the LEM AGC Luminary software.
1201 and 1202 program alarms
PGNCS generated unanticipated warnings during Apollo 11's lunar descent, with the AGC showing a 1202 alarm ("Executive overflow - NO CORE SETS"), and then a 1201 alarm ("Executive overflow - NO VAC AREAS"). The response of the AGC to either alarm was a soft restart. The cause was a rapid, steady stream of spurious cycle steals from the rendezvous radar (tracking the orbiting command module), intentionally left on standby during the descent in case it was needed for an abort.
During this part of the approach, the processor would normally be almost 85% loaded. The extra 6,400 cycle steals per second added the equivalent of 13% load, leaving just enough time for all scheduled tasks to run to completion. Five minutes into the descent, Buzz Aldrin gave the computer the command 1668, which instructed it to periodically calculate and display DELTAH (the difference between altitude sensed by the radar and the computed altitude). The 1668 added another 10% to the processor workload, causing executive overflow and a 1202 alarm. After being given the "GO" from Houston, Aldrin entered 1668 again and another 1202 alarm occurred. When reporting the second alarm, Aldrin added the comment "It appears to come up when we have a 1668 up". The AGC software had been designed with priority scheduling, and automatically recovered, deleting lower priority tasks including the 1668 display task, to complete its critical guidance and control tasks. Guidance controller Steve Bales and his support team that included Jack Garman issued several "GO" calls and the landing was successful. For his role, Bales received the US Presidential Medal of Freedom on behalf of the entire control center team and the three Apollo astronauts.
The problem was not a programming error in the AGC, nor was it pilot error. It was a peripheral hardware design bug that had already been known and documented by Apollo 5 engineers. However, because the problem had only occurred once during testing, they concluded that it was safer to fly with the existing hardware that they had already tested, than to fly with a newer but largely untested radar system. In the actual hardware, the position of the rendezvous radar was encoded with synchros excited by a different source of 800 Hz AC than the one used by the computer as a timing reference. The two 800 Hz sources were frequency locked but not phase locked, and the small random phase variations made it appear as though the antenna was rapidly "dithering" in position, even though it was completely stationary. These phantom movements generated the rapid series of cycle steals.
J. Halcombe Laning's software and computer design saved the Apollo 11 landing mission.  Had it not been for Laning's design, the landing would have been aborted for lack of a stable guidance computer.
Applications outside Apollo
The AGC formed the basis of an experimental fly-by-wire (FBW) system installed into an F-8 Crusader to demonstrate the practicality of computer driven FBW. The AGC used in the first phase of the program was replaced with another machine in the second phase, and research done on the program led to the development of fly-by-wire systems for the Space Shuttle. The AGC also led, albeit indirectly, to the development of fly-by-wire systems for the generation of fighters that were being developed at the time.
The AGC was also used for the United States Navy's Deep Submergence Rescue Vehicle.
Source code release
In 2003, an effort was started by Ron Burkey to recover the source code that powered the AGC and build an emulator able to run it, the VirtualAGC. Part of the large amount of source code rescued as a result of this effort was uploaded by a former NASA intern to GitHub on July 7, 2016, attracting significant media attention. The original Apollo 11 Guidance Computer source code was originally made accessible in 2003 by the Virtual AGC Project and MIT Museum. It was transcribed and digitalized from the original hard-copy source code listings that were made in the 60s. In mid 2016, former NASA intern, Chris Garry, uploaded the AGC Source code onto GitHub.
See also
Notes